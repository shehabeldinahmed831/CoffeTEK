{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.resolveURI = factory());\n})(this, function () {\n  'use strict'; // Matches the scheme of a URL, eg \"http://\"\n\n  const schemeRegex = /^[\\w+.-]+:\\/\\//;\n  /**\n   * Matches the parts of a URL:\n   * 1. Scheme, including \":\", guaranteed.\n   * 2. User/password, including \"@\", optional.\n   * 3. Host, guaranteed.\n   * 4. Port, including \":\", optional.\n   * 5. Path, including \"/\", optional.\n   * 6. Query, including \"?\", optional.\n   * 7. Hash, including \"#\", optional.\n   */\n\n  const urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n  /**\n   * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n   * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n   *\n   * 1. Host, optional.\n   * 2. Path, which may include \"/\", guaranteed.\n   * 3. Query, including \"?\", optional.\n   * 4. Hash, including \"#\", optional.\n   */\n\n  const fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n  var UrlType;\n\n  (function (UrlType) {\n    UrlType[UrlType[\"Empty\"] = 1] = \"Empty\";\n    UrlType[UrlType[\"Hash\"] = 2] = \"Hash\";\n    UrlType[UrlType[\"Query\"] = 3] = \"Query\";\n    UrlType[UrlType[\"RelativePath\"] = 4] = \"RelativePath\";\n    UrlType[UrlType[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n    UrlType[UrlType[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n    UrlType[UrlType[\"Absolute\"] = 7] = \"Absolute\";\n  })(UrlType || (UrlType = {}));\n\n  function isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n  }\n\n  function isSchemeRelativeUrl(input) {\n    return input.startsWith('//');\n  }\n\n  function isAbsolutePath(input) {\n    return input.startsWith('/');\n  }\n\n  function isFileUrl(input) {\n    return input.startsWith('file:');\n  }\n\n  function isRelative(input) {\n    return /^[.?#]/.test(input);\n  }\n\n  function parseAbsoluteUrl(input) {\n    const match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n  }\n\n  function parseFileUrl(input) {\n    const match = fileRegex.exec(input);\n    const path = match[2];\n    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n  }\n\n  function makeUrl(scheme, user, host, port, path, query, hash) {\n    return {\n      scheme,\n      user,\n      host,\n      port,\n      path,\n      query,\n      hash,\n      type: UrlType.Absolute\n    };\n  }\n\n  function parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n      const url = parseAbsoluteUrl('http:' + input);\n      url.scheme = '';\n      url.type = UrlType.SchemeRelative;\n      return url;\n    }\n\n    if (isAbsolutePath(input)) {\n      const url = parseAbsoluteUrl('http://foo.com' + input);\n      url.scheme = '';\n      url.host = '';\n      url.type = UrlType.AbsolutePath;\n      return url;\n    }\n\n    if (isFileUrl(input)) return parseFileUrl(input);\n    if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n    const url = parseAbsoluteUrl('http://foo.com/' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = input ? input.startsWith('?') ? UrlType.Query : input.startsWith('#') ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;\n    return url;\n  }\n\n  function stripPathFilename(path) {\n    // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n    // paths. It's not a file, so we can't strip it.\n    if (path.endsWith('/..')) return path;\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n  }\n\n  function mergePaths(url, base) {\n    normalizePath(base, base.type); // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n    // path).\n\n    if (url.path === '/') {\n      url.path = base.path;\n    } else {\n      // Resolution happens relative to the base path's directory, not the file.\n      url.path = stripPathFilename(base.path) + url.path;\n    }\n  }\n  /**\n   * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n   * \"foo/.\". We need to normalize to a standard representation.\n   */\n\n\n  function normalizePath(url, type) {\n    const rel = type <= UrlType.RelativePath;\n    const pieces = url.path.split('/'); // We need to preserve the first piece always, so that we output a leading slash. The item at\n    // pieces[0] is an empty string.\n\n    let pointer = 1; // Positive is the number of real directories we've output, used for popping a parent directory.\n    // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n\n    let positive = 0; // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n    // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n    // real directory, we won't need to append, unless the other conditions happen again.\n\n    let addTrailingSlash = false;\n\n    for (let i = 1; i < pieces.length; i++) {\n      const piece = pieces[i]; // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n\n      if (!piece) {\n        addTrailingSlash = true;\n        continue;\n      } // If we encounter a real directory, then we don't need to append anymore.\n\n\n      addTrailingSlash = false; // A current directory, which we can always drop.\n\n      if (piece === '.') continue; // A parent directory, we need to see if there are any real directories we can pop. Else, we\n      // have an excess of parents, and we'll need to keep the \"..\".\n\n      if (piece === '..') {\n        if (positive) {\n          addTrailingSlash = true;\n          positive--;\n          pointer--;\n        } else if (rel) {\n          // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n          // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n          pieces[pointer++] = piece;\n        }\n\n        continue;\n      } // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n      // any popped or dropped directories.\n\n\n      pieces[pointer++] = piece;\n      positive++;\n    }\n\n    let path = '';\n\n    for (let i = 1; i < pointer; i++) {\n      path += '/' + pieces[i];\n    }\n\n    if (!path || addTrailingSlash && !path.endsWith('/..')) {\n      path += '/';\n    }\n\n    url.path = path;\n  }\n  /**\n   * Attempts to resolve `input` URL/path relative to `base`.\n   */\n\n\n  function resolve(input, base) {\n    if (!input && !base) return '';\n    const url = parseUrl(input);\n    let inputType = url.type;\n\n    if (base && inputType !== UrlType.Absolute) {\n      const baseUrl = parseUrl(base);\n      const baseType = baseUrl.type;\n\n      switch (inputType) {\n        case UrlType.Empty:\n          url.hash = baseUrl.hash;\n        // fall through\n\n        case UrlType.Hash:\n          url.query = baseUrl.query;\n        // fall through\n\n        case UrlType.Query:\n        case UrlType.RelativePath:\n          mergePaths(url, baseUrl);\n        // fall through\n\n        case UrlType.AbsolutePath:\n          // The host, user, and port are joined, you can't copy one without the others.\n          url.user = baseUrl.user;\n          url.host = baseUrl.host;\n          url.port = baseUrl.port;\n        // fall through\n\n        case UrlType.SchemeRelative:\n          // The input doesn't have a schema at least, so we need to copy at least that over.\n          url.scheme = baseUrl.scheme;\n      }\n\n      if (baseType > inputType) inputType = baseType;\n    }\n\n    normalizePath(url, inputType);\n    const queryHash = url.query + url.hash;\n\n    switch (inputType) {\n      // This is impossible, because of the empty checks at the start of the function.\n      // case UrlType.Empty:\n      case UrlType.Hash:\n      case UrlType.Query:\n        return queryHash;\n\n      case UrlType.RelativePath:\n        {\n          // The first char is always a \"/\", and we need it to be relative.\n          const path = url.path.slice(1);\n          if (!path) return queryHash || '.';\n\n          if (isRelative(base || input) && !isRelative(path)) {\n            // If base started with a leading \".\", or there is no base and input started with a \".\",\n            // then we need to ensure that the relative path starts with a \".\". We don't know if\n            // relative starts with a \"..\", though, so check before prepending.\n            return './' + path + queryHash;\n          }\n\n          return path + queryHash;\n        }\n\n      case UrlType.AbsolutePath:\n        return url.path + queryHash;\n\n      default:\n        return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n    }\n  }\n\n  return resolve;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","globalThis","self","resolveURI","schemeRegex","urlRegex","fileRegex","UrlType","isAbsoluteUrl","input","test","isSchemeRelativeUrl","startsWith","isAbsolutePath","isFileUrl","isRelative","parseAbsoluteUrl","match","exec","makeUrl","parseFileUrl","path","scheme","user","host","port","query","hash","type","Absolute","parseUrl","url","SchemeRelative","AbsolutePath","Query","Hash","RelativePath","Empty","stripPathFilename","endsWith","index","lastIndexOf","slice","mergePaths","base","normalizePath","rel","pieces","split","pointer","positive","addTrailingSlash","i","length","piece","resolve","inputType","baseUrl","baseType","queryHash"],"sources":["D:/WebDev/dfproject/gp/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.resolveURI = factory());\n})(this, (function () { 'use strict';\n\n    // Matches the scheme of a URL, eg \"http://\"\n    const schemeRegex = /^[\\w+.-]+:\\/\\//;\n    /**\n     * Matches the parts of a URL:\n     * 1. Scheme, including \":\", guaranteed.\n     * 2. User/password, including \"@\", optional.\n     * 3. Host, guaranteed.\n     * 4. Port, including \":\", optional.\n     * 5. Path, including \"/\", optional.\n     * 6. Query, including \"?\", optional.\n     * 7. Hash, including \"#\", optional.\n     */\n    const urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n    /**\n     * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n     * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n     *\n     * 1. Host, optional.\n     * 2. Path, which may include \"/\", guaranteed.\n     * 3. Query, including \"?\", optional.\n     * 4. Hash, including \"#\", optional.\n     */\n    const fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n    var UrlType;\n    (function (UrlType) {\n        UrlType[UrlType[\"Empty\"] = 1] = \"Empty\";\n        UrlType[UrlType[\"Hash\"] = 2] = \"Hash\";\n        UrlType[UrlType[\"Query\"] = 3] = \"Query\";\n        UrlType[UrlType[\"RelativePath\"] = 4] = \"RelativePath\";\n        UrlType[UrlType[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n        UrlType[UrlType[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n        UrlType[UrlType[\"Absolute\"] = 7] = \"Absolute\";\n    })(UrlType || (UrlType = {}));\n    function isAbsoluteUrl(input) {\n        return schemeRegex.test(input);\n    }\n    function isSchemeRelativeUrl(input) {\n        return input.startsWith('//');\n    }\n    function isAbsolutePath(input) {\n        return input.startsWith('/');\n    }\n    function isFileUrl(input) {\n        return input.startsWith('file:');\n    }\n    function isRelative(input) {\n        return /^[.?#]/.test(input);\n    }\n    function parseAbsoluteUrl(input) {\n        const match = urlRegex.exec(input);\n        return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n    }\n    function parseFileUrl(input) {\n        const match = fileRegex.exec(input);\n        const path = match[2];\n        return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n    }\n    function makeUrl(scheme, user, host, port, path, query, hash) {\n        return {\n            scheme,\n            user,\n            host,\n            port,\n            path,\n            query,\n            hash,\n            type: UrlType.Absolute,\n        };\n    }\n    function parseUrl(input) {\n        if (isSchemeRelativeUrl(input)) {\n            const url = parseAbsoluteUrl('http:' + input);\n            url.scheme = '';\n            url.type = UrlType.SchemeRelative;\n            return url;\n        }\n        if (isAbsolutePath(input)) {\n            const url = parseAbsoluteUrl('http://foo.com' + input);\n            url.scheme = '';\n            url.host = '';\n            url.type = UrlType.AbsolutePath;\n            return url;\n        }\n        if (isFileUrl(input))\n            return parseFileUrl(input);\n        if (isAbsoluteUrl(input))\n            return parseAbsoluteUrl(input);\n        const url = parseAbsoluteUrl('http://foo.com/' + input);\n        url.scheme = '';\n        url.host = '';\n        url.type = input\n            ? input.startsWith('?')\n                ? UrlType.Query\n                : input.startsWith('#')\n                    ? UrlType.Hash\n                    : UrlType.RelativePath\n            : UrlType.Empty;\n        return url;\n    }\n    function stripPathFilename(path) {\n        // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n        // paths. It's not a file, so we can't strip it.\n        if (path.endsWith('/..'))\n            return path;\n        const index = path.lastIndexOf('/');\n        return path.slice(0, index + 1);\n    }\n    function mergePaths(url, base) {\n        normalizePath(base, base.type);\n        // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n        // path).\n        if (url.path === '/') {\n            url.path = base.path;\n        }\n        else {\n            // Resolution happens relative to the base path's directory, not the file.\n            url.path = stripPathFilename(base.path) + url.path;\n        }\n    }\n    /**\n     * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n     * \"foo/.\". We need to normalize to a standard representation.\n     */\n    function normalizePath(url, type) {\n        const rel = type <= UrlType.RelativePath;\n        const pieces = url.path.split('/');\n        // We need to preserve the first piece always, so that we output a leading slash. The item at\n        // pieces[0] is an empty string.\n        let pointer = 1;\n        // Positive is the number of real directories we've output, used for popping a parent directory.\n        // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n        let positive = 0;\n        // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n        // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n        // real directory, we won't need to append, unless the other conditions happen again.\n        let addTrailingSlash = false;\n        for (let i = 1; i < pieces.length; i++) {\n            const piece = pieces[i];\n            // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n            if (!piece) {\n                addTrailingSlash = true;\n                continue;\n            }\n            // If we encounter a real directory, then we don't need to append anymore.\n            addTrailingSlash = false;\n            // A current directory, which we can always drop.\n            if (piece === '.')\n                continue;\n            // A parent directory, we need to see if there are any real directories we can pop. Else, we\n            // have an excess of parents, and we'll need to keep the \"..\".\n            if (piece === '..') {\n                if (positive) {\n                    addTrailingSlash = true;\n                    positive--;\n                    pointer--;\n                }\n                else if (rel) {\n                    // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n                    // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n                    pieces[pointer++] = piece;\n                }\n                continue;\n            }\n            // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n            // any popped or dropped directories.\n            pieces[pointer++] = piece;\n            positive++;\n        }\n        let path = '';\n        for (let i = 1; i < pointer; i++) {\n            path += '/' + pieces[i];\n        }\n        if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n            path += '/';\n        }\n        url.path = path;\n    }\n    /**\n     * Attempts to resolve `input` URL/path relative to `base`.\n     */\n    function resolve(input, base) {\n        if (!input && !base)\n            return '';\n        const url = parseUrl(input);\n        let inputType = url.type;\n        if (base && inputType !== UrlType.Absolute) {\n            const baseUrl = parseUrl(base);\n            const baseType = baseUrl.type;\n            switch (inputType) {\n                case UrlType.Empty:\n                    url.hash = baseUrl.hash;\n                // fall through\n                case UrlType.Hash:\n                    url.query = baseUrl.query;\n                // fall through\n                case UrlType.Query:\n                case UrlType.RelativePath:\n                    mergePaths(url, baseUrl);\n                // fall through\n                case UrlType.AbsolutePath:\n                    // The host, user, and port are joined, you can't copy one without the others.\n                    url.user = baseUrl.user;\n                    url.host = baseUrl.host;\n                    url.port = baseUrl.port;\n                // fall through\n                case UrlType.SchemeRelative:\n                    // The input doesn't have a schema at least, so we need to copy at least that over.\n                    url.scheme = baseUrl.scheme;\n            }\n            if (baseType > inputType)\n                inputType = baseType;\n        }\n        normalizePath(url, inputType);\n        const queryHash = url.query + url.hash;\n        switch (inputType) {\n            // This is impossible, because of the empty checks at the start of the function.\n            // case UrlType.Empty:\n            case UrlType.Hash:\n            case UrlType.Query:\n                return queryHash;\n            case UrlType.RelativePath: {\n                // The first char is always a \"/\", and we need it to be relative.\n                const path = url.path.slice(1);\n                if (!path)\n                    return queryHash || '.';\n                if (isRelative(base || input) && !isRelative(path)) {\n                    // If base started with a leading \".\", or there is no base and input started with a \".\",\n                    // then we need to ensure that the relative path starts with a \".\". We don't know if\n                    // relative starts with a \"..\", though, so check before prepending.\n                    return './' + path + queryHash;\n                }\n                return path + queryHash;\n            }\n            case UrlType.AbsolutePath:\n                return url.path + queryHash;\n            default:\n                return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n        }\n    }\n\n    return resolve;\n\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}