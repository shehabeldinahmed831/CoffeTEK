{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\"use strict\";\n\nvar _asyncToGenerator = require(\"D:/WebDev/dfproject/gp/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst {\n  constants\n} = require(\"buffer\");\n\nconst {\n  pipeline\n} = require(\"stream\");\n\nconst {\n  createBrotliCompress,\n  createBrotliDecompress,\n  createGzip,\n  createGunzip,\n  constants: zConstants\n} = require(\"zlib\");\n\nconst createHash = require(\"../util/createHash\");\n\nconst {\n  dirname,\n  join,\n  mkdirp\n} = require(\"../util/fs\");\n\nconst memoize = require(\"../util/memoize\");\n\nconst SerializerMiddleware = require(\"./SerializerMiddleware\");\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\n/** @typedef {import(\"./types\").BufferSerializableType} BufferSerializableType */\n\n/*\nFormat:\n\nFile -> Header Section*\n\nVersion -> u32\nAmountOfSections -> u32\nSectionSize -> i32 (if less than zero represents lazy value)\n\nHeader -> Version AmountOfSections SectionSize*\n\nBuffer -> n bytes\nSection -> Buffer\n\n*/\n// \"wpc\" + 1 in little-endian\n\n\nconst VERSION = 0x01637077;\nconst WRITE_LIMIT_TOTAL = 0x7fff0000;\nconst WRITE_LIMIT_CHUNK = 511 * 1024 * 1024;\n/**\n * @param {Buffer[]} buffers buffers\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\n\nconst hashForName = (buffers, hashFunction) => {\n  const hash = createHash(hashFunction);\n\n  for (const buf of buffers) hash.update(buf);\n\n  return (\n    /** @type {string} */\n    hash.digest(\"hex\")\n  );\n};\n\nconst COMPRESSION_CHUNK_SIZE = 100 * 1024 * 1024;\nconst DECOMPRESSION_CHUNK_SIZE = 100 * 1024 * 1024;\nconst writeUInt64LE = Buffer.prototype.writeBigUInt64LE ? (buf, value, offset) => {\n  buf.writeBigUInt64LE(BigInt(value), offset);\n} : (buf, value, offset) => {\n  const low = value % 0x100000000;\n  const high = (value - low) / 0x100000000;\n  buf.writeUInt32LE(low, offset);\n  buf.writeUInt32LE(high, offset + 4);\n};\nconst readUInt64LE = Buffer.prototype.readBigUInt64LE ? (buf, offset) => {\n  return Number(buf.readBigUInt64LE(offset));\n} : (buf, offset) => {\n  const low = buf.readUInt32LE(offset);\n  const high = buf.readUInt32LE(offset + 4);\n  return high * 0x100000000 + low;\n};\n/**\n * @typedef {Object} SerializeResult\n * @property {string | false} name\n * @property {number} size\n * @property {Promise=} backgroundJob\n */\n\n/**\n * @param {FileMiddleware} middleware this\n * @param {BufferSerializableType[] | Promise<BufferSerializableType[]>} data data to be serialized\n * @param {string | boolean} name file base name\n * @param {function(string | false, Buffer[], number): Promise<void>} writeFile writes a file\n * @param {string | Hash} hashFunction hash function to use\n * @returns {Promise<SerializeResult>} resulting file pointer and promise\n */\n\nconst serialize = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (middleware, data, name, writeFile, hashFunction = \"md4\") {\n    /** @type {(Buffer[] | Buffer | SerializeResult | Promise<SerializeResult>)[]} */\n    const processedData = [];\n    /** @type {WeakMap<SerializeResult, function(): any | Promise<any>>} */\n\n    const resultToLazy = new WeakMap();\n    /** @type {Buffer[]} */\n\n    let lastBuffers = undefined;\n\n    for (const item of yield data) {\n      if (typeof item === \"function\") {\n        if (!SerializerMiddleware.isLazy(item)) throw new Error(\"Unexpected function\");\n\n        if (!SerializerMiddleware.isLazy(item, middleware)) {\n          throw new Error(\"Unexpected lazy value with non-this target (can't pass through lazy values)\");\n        }\n\n        lastBuffers = undefined;\n        const serializedInfo = SerializerMiddleware.getLazySerializedValue(item);\n\n        if (serializedInfo) {\n          if (typeof serializedInfo === \"function\") {\n            throw new Error(\"Unexpected lazy value with non-this target (can't pass through lazy values)\");\n          } else {\n            processedData.push(serializedInfo);\n          }\n        } else {\n          const content = item();\n\n          if (content) {\n            const options = SerializerMiddleware.getLazyOptions(item);\n            processedData.push(serialize(middleware, content, options && options.name || true, writeFile, hashFunction).then(result => {\n              /** @type {any} */\n              item.options.size = result.size;\n              resultToLazy.set(result, item);\n              return result;\n            }));\n          } else {\n            throw new Error(\"Unexpected falsy value returned by lazy value function\");\n          }\n        }\n      } else if (item) {\n        if (lastBuffers) {\n          lastBuffers.push(item);\n        } else {\n          lastBuffers = [item];\n          processedData.push(lastBuffers);\n        }\n      } else {\n        throw new Error(\"Unexpected falsy value in items array\");\n      }\n    }\n    /** @type {Promise<any>[]} */\n\n\n    const backgroundJobs = [];\n    const resolvedData = (yield Promise.all(\n    /** @type {Promise<Buffer[] | Buffer | SerializeResult>[]} */\n    processedData)).map(item => {\n      if (Array.isArray(item) || Buffer.isBuffer(item)) return item;\n      backgroundJobs.push(item.backgroundJob); // create pointer buffer from size and name\n\n      const name =\n      /** @type {string} */\n      item.name;\n      const nameBuffer = Buffer.from(name);\n      const buf = Buffer.allocUnsafe(8 + nameBuffer.length);\n      writeUInt64LE(buf, item.size, 0);\n      nameBuffer.copy(buf, 8, 0);\n      const lazy = resultToLazy.get(item);\n      SerializerMiddleware.setLazySerializedValue(lazy, buf);\n      return buf;\n    });\n    const lengths = [];\n\n    for (const item of resolvedData) {\n      if (Array.isArray(item)) {\n        let l = 0;\n\n        for (const b of item) l += b.length;\n\n        while (l > 0x7fffffff) {\n          lengths.push(0x7fffffff);\n          l -= 0x7fffffff;\n        }\n\n        lengths.push(l);\n      } else if (item) {\n        lengths.push(-item.length);\n      } else {\n        throw new Error(\"Unexpected falsy value in resolved data \" + item);\n      }\n    }\n\n    const header = Buffer.allocUnsafe(8 + lengths.length * 4);\n    header.writeUInt32LE(VERSION, 0);\n    header.writeUInt32LE(lengths.length, 4);\n\n    for (let i = 0; i < lengths.length; i++) {\n      header.writeInt32LE(lengths[i], 8 + i * 4);\n    }\n\n    const buf = [header];\n\n    for (const item of resolvedData) {\n      if (Array.isArray(item)) {\n        for (const b of item) buf.push(b);\n      } else if (item) {\n        buf.push(item);\n      }\n    }\n\n    if (name === true) {\n      name = hashForName(buf, hashFunction);\n    }\n\n    let size = 0;\n\n    for (const b of buf) size += b.length;\n\n    backgroundJobs.push(writeFile(name, buf, size));\n    return {\n      size,\n      name,\n      backgroundJob: backgroundJobs.length === 1 ? backgroundJobs[0] : Promise.all(backgroundJobs)\n    };\n  });\n\n  return function serialize(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * @param {FileMiddleware} middleware this\n * @param {string | false} name filename\n * @param {function(string | false): Promise<Buffer[]>} readFile read content of a file\n * @returns {Promise<BufferSerializableType[]>} deserialized data\n */\n\n\nconst deserialize = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (middleware, name, readFile) {\n    const contents = yield readFile(name);\n    if (contents.length === 0) throw new Error(\"Empty file \" + name);\n    let contentsIndex = 0;\n    let contentItem = contents[0];\n    let contentItemLength = contentItem.length;\n    let contentPosition = 0;\n    if (contentItemLength === 0) throw new Error(\"Empty file \" + name);\n\n    const nextContent = () => {\n      contentsIndex++;\n      contentItem = contents[contentsIndex];\n      contentItemLength = contentItem.length;\n      contentPosition = 0;\n    };\n\n    const ensureData = n => {\n      if (contentPosition === contentItemLength) {\n        nextContent();\n      }\n\n      while (contentItemLength - contentPosition < n) {\n        const remaining = contentItem.slice(contentPosition);\n        let lengthFromNext = n - remaining.length;\n        const buffers = [remaining];\n\n        for (let i = contentsIndex + 1; i < contents.length; i++) {\n          const l = contents[i].length;\n\n          if (l > lengthFromNext) {\n            buffers.push(contents[i].slice(0, lengthFromNext));\n            contents[i] = contents[i].slice(lengthFromNext);\n            lengthFromNext = 0;\n            break;\n          } else {\n            buffers.push(contents[i]);\n            contentsIndex = i;\n            lengthFromNext -= l;\n          }\n        }\n\n        if (lengthFromNext > 0) throw new Error(\"Unexpected end of data\");\n        contentItem = Buffer.concat(buffers, n);\n        contentItemLength = n;\n        contentPosition = 0;\n      }\n    };\n\n    const readUInt32LE = () => {\n      ensureData(4);\n      const value = contentItem.readUInt32LE(contentPosition);\n      contentPosition += 4;\n      return value;\n    };\n\n    const readInt32LE = () => {\n      ensureData(4);\n      const value = contentItem.readInt32LE(contentPosition);\n      contentPosition += 4;\n      return value;\n    };\n\n    const readSlice = l => {\n      ensureData(l);\n\n      if (contentPosition === 0 && contentItemLength === l) {\n        const result = contentItem;\n\n        if (contentsIndex + 1 < contents.length) {\n          nextContent();\n        } else {\n          contentPosition = l;\n        }\n\n        return result;\n      }\n\n      const result = contentItem.slice(contentPosition, contentPosition + l);\n      contentPosition += l; // we clone the buffer here to allow the original content to be garbage collected\n\n      return l * 2 < contentItem.buffer.byteLength ? Buffer.from(result) : result;\n    };\n\n    const version = readUInt32LE();\n\n    if (version !== VERSION) {\n      throw new Error(\"Invalid file version\");\n    }\n\n    const sectionCount = readUInt32LE();\n    const lengths = [];\n    let lastLengthPositive = false;\n\n    for (let i = 0; i < sectionCount; i++) {\n      const value = readInt32LE();\n      const valuePositive = value >= 0;\n\n      if (lastLengthPositive && valuePositive) {\n        lengths[lengths.length - 1] += value;\n      } else {\n        lengths.push(value);\n        lastLengthPositive = valuePositive;\n      }\n    }\n\n    const result = [];\n\n    for (let length of lengths) {\n      if (length < 0) {\n        const slice = readSlice(-length);\n        const size = Number(readUInt64LE(slice, 0));\n        const nameBuffer = slice.slice(8);\n        const name = nameBuffer.toString();\n        result.push(SerializerMiddleware.createLazy(memoize(() => deserialize(middleware, name, readFile)), middleware, {\n          name,\n          size\n        }, slice));\n      } else {\n        if (contentPosition === contentItemLength) {\n          nextContent();\n        } else if (contentPosition !== 0) {\n          if (length <= contentItemLength - contentPosition) {\n            result.push(Buffer.from(contentItem.buffer, contentItem.byteOffset + contentPosition, length));\n            contentPosition += length;\n            length = 0;\n          } else {\n            const l = contentItemLength - contentPosition;\n            result.push(Buffer.from(contentItem.buffer, contentItem.byteOffset + contentPosition, l));\n            length -= l;\n            contentPosition = contentItemLength;\n          }\n        } else {\n          if (length >= contentItemLength) {\n            result.push(contentItem);\n            length -= contentItemLength;\n            contentPosition = contentItemLength;\n          } else {\n            result.push(Buffer.from(contentItem.buffer, contentItem.byteOffset, length));\n            contentPosition += length;\n            length = 0;\n          }\n        }\n\n        while (length > 0) {\n          nextContent();\n\n          if (length >= contentItemLength) {\n            result.push(contentItem);\n            length -= contentItemLength;\n            contentPosition = contentItemLength;\n          } else {\n            result.push(Buffer.from(contentItem.buffer, contentItem.byteOffset, length));\n            contentPosition += length;\n            length = 0;\n          }\n        }\n      }\n    }\n\n    return result;\n  });\n\n  return function deserialize(_x5, _x6, _x7) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * @typedef {BufferSerializableType[]} DeserializedType\n * @typedef {true} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\n\n\nclass FileMiddleware extends SerializerMiddleware {\n  /**\n   * @param {IntermediateFileSystem} fs filesystem\n   * @param {string | Hash} hashFunction hash function to use\n   */\n  constructor(fs, hashFunction = \"md4\") {\n    super();\n    this.fs = fs;\n    this._hashFunction = hashFunction;\n  }\n  /**\n   * @param {DeserializedType} data data\n   * @param {Object} context context object\n   * @returns {SerializedType|Promise<SerializedType>} serialized data\n   */\n\n\n  serialize(data, context) {\n    var _this = this;\n\n    const {\n      filename,\n      extension = \"\"\n    } = context;\n    return new Promise((resolve, reject) => {\n      mkdirp(this.fs, dirname(this.fs, filename), err => {\n        if (err) return reject(err); // It's important that we don't touch existing files during serialization\n        // because serialize may read existing files (when deserializing)\n\n        const allWrittenFiles = new Set();\n\n        const writeFile = /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator(function* (name, content, size) {\n            const file = name ? join(_this.fs, filename, `../${name}${extension}`) : filename;\n            yield new Promise((resolve, reject) => {\n              let stream = _this.fs.createWriteStream(file + \"_\");\n\n              let compression;\n\n              if (file.endsWith(\".gz\")) {\n                compression = createGzip({\n                  chunkSize: COMPRESSION_CHUNK_SIZE,\n                  level: zConstants.Z_BEST_SPEED\n                });\n              } else if (file.endsWith(\".br\")) {\n                compression = createBrotliCompress({\n                  chunkSize: COMPRESSION_CHUNK_SIZE,\n                  params: {\n                    [zConstants.BROTLI_PARAM_MODE]: zConstants.BROTLI_MODE_TEXT,\n                    [zConstants.BROTLI_PARAM_QUALITY]: 2,\n                    [zConstants.BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING]: true,\n                    [zConstants.BROTLI_PARAM_SIZE_HINT]: size\n                  }\n                });\n              }\n\n              if (compression) {\n                pipeline(compression, stream, reject);\n                stream = compression;\n                stream.on(\"finish\", () => resolve());\n              } else {\n                stream.on(\"error\", err => reject(err));\n                stream.on(\"finish\", () => resolve());\n              } // split into chunks for WRITE_LIMIT_CHUNK size\n\n\n              const chunks = [];\n\n              for (const b of content) {\n                if (b.length < WRITE_LIMIT_CHUNK) {\n                  chunks.push(b);\n                } else {\n                  for (let i = 0; i < b.length; i += WRITE_LIMIT_CHUNK) {\n                    chunks.push(b.slice(i, i + WRITE_LIMIT_CHUNK));\n                  }\n                }\n              }\n\n              const len = chunks.length;\n              let i = 0;\n\n              const batchWrite = err => {\n                // will be handled in \"on\" error handler\n                if (err) return;\n\n                if (i === len) {\n                  stream.end();\n                  return;\n                } // queue up a batch of chunks up to the write limit\n                // end is exclusive\n\n\n                let end = i;\n                let sum = chunks[end++].length;\n\n                while (end < len) {\n                  sum += chunks[end].length;\n                  if (sum > WRITE_LIMIT_TOTAL) break;\n                  end++;\n                }\n\n                while (i < end - 1) {\n                  stream.write(chunks[i++]);\n                }\n\n                stream.write(chunks[i++], batchWrite);\n              };\n\n              batchWrite();\n            });\n            if (name) allWrittenFiles.add(file);\n          });\n\n          return function writeFile(_x8, _x9, _x10) {\n            return _ref3.apply(this, arguments);\n          };\n        }();\n\n        resolve(serialize(this, data, false, writeFile, this._hashFunction).then( /*#__PURE__*/function () {\n          var _ref4 = _asyncToGenerator(function* ({\n            backgroundJob\n          }) {\n            yield backgroundJob; // Rename the index file to disallow access during inconsistent file state\n\n            yield new Promise(resolve => _this.fs.rename(filename, filename + \".old\", err => {\n              resolve();\n            })); // update all written files\n\n            yield Promise.all(Array.from(allWrittenFiles, file => new Promise((resolve, reject) => {\n              _this.fs.rename(file + \"_\", file, err => {\n                if (err) return reject(err);\n                resolve();\n              });\n            }))); // As final step automatically update the index file to have a consistent pack again\n\n            yield new Promise(resolve => {\n              _this.fs.rename(filename + \"_\", filename, err => {\n                if (err) return reject(err);\n                resolve();\n              });\n            });\n            return (\n              /** @type {true} */\n              true\n            );\n          });\n\n          return function (_x11) {\n            return _ref4.apply(this, arguments);\n          };\n        }()));\n      });\n    });\n  }\n  /**\n   * @param {SerializedType} data data\n   * @param {Object} context context object\n   * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n   */\n\n\n  deserialize(data, context) {\n    const {\n      filename,\n      extension = \"\"\n    } = context;\n\n    const readFile = name => new Promise((resolve, reject) => {\n      const file = name ? join(this.fs, filename, `../${name}${extension}`) : filename;\n      this.fs.stat(file, (err, stats) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        let remaining =\n        /** @type {number} */\n        stats.size;\n        let currentBuffer;\n        let currentBufferUsed;\n        const buf = [];\n        let decompression;\n\n        if (file.endsWith(\".gz\")) {\n          decompression = createGunzip({\n            chunkSize: DECOMPRESSION_CHUNK_SIZE\n          });\n        } else if (file.endsWith(\".br\")) {\n          decompression = createBrotliDecompress({\n            chunkSize: DECOMPRESSION_CHUNK_SIZE\n          });\n        }\n\n        if (decompression) {\n          let newResolve, newReject;\n          resolve(Promise.all([new Promise((rs, rj) => {\n            newResolve = rs;\n            newReject = rj;\n          }), new Promise((resolve, reject) => {\n            decompression.on(\"data\", chunk => buf.push(chunk));\n            decompression.on(\"end\", () => resolve());\n            decompression.on(\"error\", err => reject(err));\n          })]).then(() => buf));\n          resolve = newResolve;\n          reject = newReject;\n        }\n\n        this.fs.open(file, \"r\", (err, fd) => {\n          if (err) {\n            reject(err);\n            return;\n          }\n\n          const read = () => {\n            if (currentBuffer === undefined) {\n              currentBuffer = Buffer.allocUnsafeSlow(Math.min(constants.MAX_LENGTH, remaining, decompression ? DECOMPRESSION_CHUNK_SIZE : Infinity));\n              currentBufferUsed = 0;\n            }\n\n            let readBuffer = currentBuffer;\n            let readOffset = currentBufferUsed;\n            let readLength = currentBuffer.length - currentBufferUsed; // values passed to fs.read must be valid int32 values\n\n            if (readOffset > 0x7fffffff) {\n              readBuffer = currentBuffer.slice(readOffset);\n              readOffset = 0;\n            }\n\n            if (readLength > 0x7fffffff) {\n              readLength = 0x7fffffff;\n            }\n\n            this.fs.read(fd, readBuffer, readOffset, readLength, null, (err, bytesRead) => {\n              if (err) {\n                this.fs.close(fd, () => {\n                  reject(err);\n                });\n                return;\n              }\n\n              currentBufferUsed += bytesRead;\n              remaining -= bytesRead;\n\n              if (currentBufferUsed === currentBuffer.length) {\n                if (decompression) {\n                  decompression.write(currentBuffer);\n                } else {\n                  buf.push(currentBuffer);\n                }\n\n                currentBuffer = undefined;\n\n                if (remaining === 0) {\n                  if (decompression) {\n                    decompression.end();\n                  }\n\n                  this.fs.close(fd, err => {\n                    if (err) {\n                      reject(err);\n                      return;\n                    }\n\n                    resolve(buf);\n                  });\n                  return;\n                }\n              }\n\n              read();\n            });\n          };\n\n          read();\n        });\n      });\n    });\n\n    return deserialize(this, false, readFile);\n  }\n\n}\n\nmodule.exports = FileMiddleware;","map":{"version":3,"names":["constants","require","pipeline","createBrotliCompress","createBrotliDecompress","createGzip","createGunzip","zConstants","createHash","dirname","join","mkdirp","memoize","SerializerMiddleware","VERSION","WRITE_LIMIT_TOTAL","WRITE_LIMIT_CHUNK","hashForName","buffers","hashFunction","hash","buf","update","digest","COMPRESSION_CHUNK_SIZE","DECOMPRESSION_CHUNK_SIZE","writeUInt64LE","Buffer","prototype","writeBigUInt64LE","value","offset","BigInt","low","high","writeUInt32LE","readUInt64LE","readBigUInt64LE","Number","readUInt32LE","serialize","middleware","data","name","writeFile","processedData","resultToLazy","WeakMap","lastBuffers","undefined","item","isLazy","Error","serializedInfo","getLazySerializedValue","push","content","options","getLazyOptions","then","result","size","set","backgroundJobs","resolvedData","Promise","all","map","Array","isArray","isBuffer","backgroundJob","nameBuffer","from","allocUnsafe","length","copy","lazy","get","setLazySerializedValue","lengths","l","b","header","i","writeInt32LE","deserialize","readFile","contents","contentsIndex","contentItem","contentItemLength","contentPosition","nextContent","ensureData","n","remaining","slice","lengthFromNext","concat","readInt32LE","readSlice","buffer","byteLength","version","sectionCount","lastLengthPositive","valuePositive","toString","createLazy","byteOffset","FileMiddleware","constructor","fs","_hashFunction","context","filename","extension","resolve","reject","err","allWrittenFiles","Set","file","stream","createWriteStream","compression","endsWith","chunkSize","level","Z_BEST_SPEED","params","BROTLI_PARAM_MODE","BROTLI_MODE_TEXT","BROTLI_PARAM_QUALITY","BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING","BROTLI_PARAM_SIZE_HINT","on","chunks","len","batchWrite","end","sum","write","add","rename","stat","stats","currentBuffer","currentBufferUsed","decompression","newResolve","newReject","rs","rj","chunk","open","fd","read","allocUnsafeSlow","Math","min","MAX_LENGTH","Infinity","readBuffer","readOffset","readLength","bytesRead","close","module","exports"],"sources":["D:/WebDev/dfproject/gp/node_modules/webpack/lib/serialization/FileMiddleware.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst { constants } = require(\"buffer\");\nconst { pipeline } = require(\"stream\");\nconst {\n\tcreateBrotliCompress,\n\tcreateBrotliDecompress,\n\tcreateGzip,\n\tcreateGunzip,\n\tconstants: zConstants\n} = require(\"zlib\");\nconst createHash = require(\"../util/createHash\");\nconst { dirname, join, mkdirp } = require(\"../util/fs\");\nconst memoize = require(\"../util/memoize\");\nconst SerializerMiddleware = require(\"./SerializerMiddleware\");\n\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n/** @typedef {import(\"./types\").BufferSerializableType} BufferSerializableType */\n\n/*\nFormat:\n\nFile -> Header Section*\n\nVersion -> u32\nAmountOfSections -> u32\nSectionSize -> i32 (if less than zero represents lazy value)\n\nHeader -> Version AmountOfSections SectionSize*\n\nBuffer -> n bytes\nSection -> Buffer\n\n*/\n\n// \"wpc\" + 1 in little-endian\nconst VERSION = 0x01637077;\nconst WRITE_LIMIT_TOTAL = 0x7fff0000;\nconst WRITE_LIMIT_CHUNK = 511 * 1024 * 1024;\n\n/**\n * @param {Buffer[]} buffers buffers\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\nconst hashForName = (buffers, hashFunction) => {\n\tconst hash = createHash(hashFunction);\n\tfor (const buf of buffers) hash.update(buf);\n\treturn /** @type {string} */ (hash.digest(\"hex\"));\n};\n\nconst COMPRESSION_CHUNK_SIZE = 100 * 1024 * 1024;\nconst DECOMPRESSION_CHUNK_SIZE = 100 * 1024 * 1024;\n\nconst writeUInt64LE = Buffer.prototype.writeBigUInt64LE\n\t? (buf, value, offset) => {\n\t\t\tbuf.writeBigUInt64LE(BigInt(value), offset);\n\t  }\n\t: (buf, value, offset) => {\n\t\t\tconst low = value % 0x100000000;\n\t\t\tconst high = (value - low) / 0x100000000;\n\t\t\tbuf.writeUInt32LE(low, offset);\n\t\t\tbuf.writeUInt32LE(high, offset + 4);\n\t  };\n\nconst readUInt64LE = Buffer.prototype.readBigUInt64LE\n\t? (buf, offset) => {\n\t\t\treturn Number(buf.readBigUInt64LE(offset));\n\t  }\n\t: (buf, offset) => {\n\t\t\tconst low = buf.readUInt32LE(offset);\n\t\t\tconst high = buf.readUInt32LE(offset + 4);\n\t\t\treturn high * 0x100000000 + low;\n\t  };\n\n/**\n * @typedef {Object} SerializeResult\n * @property {string | false} name\n * @property {number} size\n * @property {Promise=} backgroundJob\n */\n\n/**\n * @param {FileMiddleware} middleware this\n * @param {BufferSerializableType[] | Promise<BufferSerializableType[]>} data data to be serialized\n * @param {string | boolean} name file base name\n * @param {function(string | false, Buffer[], number): Promise<void>} writeFile writes a file\n * @param {string | Hash} hashFunction hash function to use\n * @returns {Promise<SerializeResult>} resulting file pointer and promise\n */\nconst serialize = async (\n\tmiddleware,\n\tdata,\n\tname,\n\twriteFile,\n\thashFunction = \"md4\"\n) => {\n\t/** @type {(Buffer[] | Buffer | SerializeResult | Promise<SerializeResult>)[]} */\n\tconst processedData = [];\n\t/** @type {WeakMap<SerializeResult, function(): any | Promise<any>>} */\n\tconst resultToLazy = new WeakMap();\n\t/** @type {Buffer[]} */\n\tlet lastBuffers = undefined;\n\tfor (const item of await data) {\n\t\tif (typeof item === \"function\") {\n\t\t\tif (!SerializerMiddleware.isLazy(item))\n\t\t\t\tthrow new Error(\"Unexpected function\");\n\t\t\tif (!SerializerMiddleware.isLazy(item, middleware)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Unexpected lazy value with non-this target (can't pass through lazy values)\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tlastBuffers = undefined;\n\t\t\tconst serializedInfo = SerializerMiddleware.getLazySerializedValue(item);\n\t\t\tif (serializedInfo) {\n\t\t\t\tif (typeof serializedInfo === \"function\") {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\"Unexpected lazy value with non-this target (can't pass through lazy values)\"\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tprocessedData.push(serializedInfo);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst content = item();\n\t\t\t\tif (content) {\n\t\t\t\t\tconst options = SerializerMiddleware.getLazyOptions(item);\n\t\t\t\t\tprocessedData.push(\n\t\t\t\t\t\tserialize(\n\t\t\t\t\t\t\tmiddleware,\n\t\t\t\t\t\t\tcontent,\n\t\t\t\t\t\t\t(options && options.name) || true,\n\t\t\t\t\t\t\twriteFile,\n\t\t\t\t\t\t\thashFunction\n\t\t\t\t\t\t).then(result => {\n\t\t\t\t\t\t\t/** @type {any} */ (item).options.size = result.size;\n\t\t\t\t\t\t\tresultToLazy.set(result, item);\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\"Unexpected falsy value returned by lazy value function\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (item) {\n\t\t\tif (lastBuffers) {\n\t\t\t\tlastBuffers.push(item);\n\t\t\t} else {\n\t\t\t\tlastBuffers = [item];\n\t\t\t\tprocessedData.push(lastBuffers);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\"Unexpected falsy value in items array\");\n\t\t}\n\t}\n\t/** @type {Promise<any>[]} */\n\tconst backgroundJobs = [];\n\tconst resolvedData = (\n\t\tawait Promise.all(\n\t\t\t/** @type {Promise<Buffer[] | Buffer | SerializeResult>[]} */ (\n\t\t\t\tprocessedData\n\t\t\t)\n\t\t)\n\t).map(item => {\n\t\tif (Array.isArray(item) || Buffer.isBuffer(item)) return item;\n\n\t\tbackgroundJobs.push(item.backgroundJob);\n\t\t// create pointer buffer from size and name\n\t\tconst name = /** @type {string} */ (item.name);\n\t\tconst nameBuffer = Buffer.from(name);\n\t\tconst buf = Buffer.allocUnsafe(8 + nameBuffer.length);\n\t\twriteUInt64LE(buf, item.size, 0);\n\t\tnameBuffer.copy(buf, 8, 0);\n\t\tconst lazy = resultToLazy.get(item);\n\t\tSerializerMiddleware.setLazySerializedValue(lazy, buf);\n\t\treturn buf;\n\t});\n\tconst lengths = [];\n\tfor (const item of resolvedData) {\n\t\tif (Array.isArray(item)) {\n\t\t\tlet l = 0;\n\t\t\tfor (const b of item) l += b.length;\n\t\t\twhile (l > 0x7fffffff) {\n\t\t\t\tlengths.push(0x7fffffff);\n\t\t\t\tl -= 0x7fffffff;\n\t\t\t}\n\t\t\tlengths.push(l);\n\t\t} else if (item) {\n\t\t\tlengths.push(-item.length);\n\t\t} else {\n\t\t\tthrow new Error(\"Unexpected falsy value in resolved data \" + item);\n\t\t}\n\t}\n\tconst header = Buffer.allocUnsafe(8 + lengths.length * 4);\n\theader.writeUInt32LE(VERSION, 0);\n\theader.writeUInt32LE(lengths.length, 4);\n\tfor (let i = 0; i < lengths.length; i++) {\n\t\theader.writeInt32LE(lengths[i], 8 + i * 4);\n\t}\n\tconst buf = [header];\n\tfor (const item of resolvedData) {\n\t\tif (Array.isArray(item)) {\n\t\t\tfor (const b of item) buf.push(b);\n\t\t} else if (item) {\n\t\t\tbuf.push(item);\n\t\t}\n\t}\n\tif (name === true) {\n\t\tname = hashForName(buf, hashFunction);\n\t}\n\tlet size = 0;\n\tfor (const b of buf) size += b.length;\n\tbackgroundJobs.push(writeFile(name, buf, size));\n\treturn {\n\t\tsize,\n\t\tname,\n\t\tbackgroundJob:\n\t\t\tbackgroundJobs.length === 1\n\t\t\t\t? backgroundJobs[0]\n\t\t\t\t: Promise.all(backgroundJobs)\n\t};\n};\n\n/**\n * @param {FileMiddleware} middleware this\n * @param {string | false} name filename\n * @param {function(string | false): Promise<Buffer[]>} readFile read content of a file\n * @returns {Promise<BufferSerializableType[]>} deserialized data\n */\nconst deserialize = async (middleware, name, readFile) => {\n\tconst contents = await readFile(name);\n\tif (contents.length === 0) throw new Error(\"Empty file \" + name);\n\tlet contentsIndex = 0;\n\tlet contentItem = contents[0];\n\tlet contentItemLength = contentItem.length;\n\tlet contentPosition = 0;\n\tif (contentItemLength === 0) throw new Error(\"Empty file \" + name);\n\tconst nextContent = () => {\n\t\tcontentsIndex++;\n\t\tcontentItem = contents[contentsIndex];\n\t\tcontentItemLength = contentItem.length;\n\t\tcontentPosition = 0;\n\t};\n\tconst ensureData = n => {\n\t\tif (contentPosition === contentItemLength) {\n\t\t\tnextContent();\n\t\t}\n\t\twhile (contentItemLength - contentPosition < n) {\n\t\t\tconst remaining = contentItem.slice(contentPosition);\n\t\t\tlet lengthFromNext = n - remaining.length;\n\t\t\tconst buffers = [remaining];\n\t\t\tfor (let i = contentsIndex + 1; i < contents.length; i++) {\n\t\t\t\tconst l = contents[i].length;\n\t\t\t\tif (l > lengthFromNext) {\n\t\t\t\t\tbuffers.push(contents[i].slice(0, lengthFromNext));\n\t\t\t\t\tcontents[i] = contents[i].slice(lengthFromNext);\n\t\t\t\t\tlengthFromNext = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tbuffers.push(contents[i]);\n\t\t\t\t\tcontentsIndex = i;\n\t\t\t\t\tlengthFromNext -= l;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lengthFromNext > 0) throw new Error(\"Unexpected end of data\");\n\t\t\tcontentItem = Buffer.concat(buffers, n);\n\t\t\tcontentItemLength = n;\n\t\t\tcontentPosition = 0;\n\t\t}\n\t};\n\tconst readUInt32LE = () => {\n\t\tensureData(4);\n\t\tconst value = contentItem.readUInt32LE(contentPosition);\n\t\tcontentPosition += 4;\n\t\treturn value;\n\t};\n\tconst readInt32LE = () => {\n\t\tensureData(4);\n\t\tconst value = contentItem.readInt32LE(contentPosition);\n\t\tcontentPosition += 4;\n\t\treturn value;\n\t};\n\tconst readSlice = l => {\n\t\tensureData(l);\n\t\tif (contentPosition === 0 && contentItemLength === l) {\n\t\t\tconst result = contentItem;\n\t\t\tif (contentsIndex + 1 < contents.length) {\n\t\t\t\tnextContent();\n\t\t\t} else {\n\t\t\t\tcontentPosition = l;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tconst result = contentItem.slice(contentPosition, contentPosition + l);\n\t\tcontentPosition += l;\n\t\t// we clone the buffer here to allow the original content to be garbage collected\n\t\treturn l * 2 < contentItem.buffer.byteLength ? Buffer.from(result) : result;\n\t};\n\tconst version = readUInt32LE();\n\tif (version !== VERSION) {\n\t\tthrow new Error(\"Invalid file version\");\n\t}\n\tconst sectionCount = readUInt32LE();\n\tconst lengths = [];\n\tlet lastLengthPositive = false;\n\tfor (let i = 0; i < sectionCount; i++) {\n\t\tconst value = readInt32LE();\n\t\tconst valuePositive = value >= 0;\n\t\tif (lastLengthPositive && valuePositive) {\n\t\t\tlengths[lengths.length - 1] += value;\n\t\t} else {\n\t\t\tlengths.push(value);\n\t\t\tlastLengthPositive = valuePositive;\n\t\t}\n\t}\n\tconst result = [];\n\tfor (let length of lengths) {\n\t\tif (length < 0) {\n\t\t\tconst slice = readSlice(-length);\n\t\t\tconst size = Number(readUInt64LE(slice, 0));\n\t\t\tconst nameBuffer = slice.slice(8);\n\t\t\tconst name = nameBuffer.toString();\n\t\t\tresult.push(\n\t\t\t\tSerializerMiddleware.createLazy(\n\t\t\t\t\tmemoize(() => deserialize(middleware, name, readFile)),\n\t\t\t\t\tmiddleware,\n\t\t\t\t\t{\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tsize\n\t\t\t\t\t},\n\t\t\t\t\tslice\n\t\t\t\t)\n\t\t\t);\n\t\t} else {\n\t\t\tif (contentPosition === contentItemLength) {\n\t\t\t\tnextContent();\n\t\t\t} else if (contentPosition !== 0) {\n\t\t\t\tif (length <= contentItemLength - contentPosition) {\n\t\t\t\t\tresult.push(\n\t\t\t\t\t\tBuffer.from(\n\t\t\t\t\t\t\tcontentItem.buffer,\n\t\t\t\t\t\t\tcontentItem.byteOffset + contentPosition,\n\t\t\t\t\t\t\tlength\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tcontentPosition += length;\n\t\t\t\t\tlength = 0;\n\t\t\t\t} else {\n\t\t\t\t\tconst l = contentItemLength - contentPosition;\n\t\t\t\t\tresult.push(\n\t\t\t\t\t\tBuffer.from(\n\t\t\t\t\t\t\tcontentItem.buffer,\n\t\t\t\t\t\t\tcontentItem.byteOffset + contentPosition,\n\t\t\t\t\t\t\tl\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tlength -= l;\n\t\t\t\t\tcontentPosition = contentItemLength;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (length >= contentItemLength) {\n\t\t\t\t\tresult.push(contentItem);\n\t\t\t\t\tlength -= contentItemLength;\n\t\t\t\t\tcontentPosition = contentItemLength;\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(\n\t\t\t\t\t\tBuffer.from(contentItem.buffer, contentItem.byteOffset, length)\n\t\t\t\t\t);\n\t\t\t\t\tcontentPosition += length;\n\t\t\t\t\tlength = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (length > 0) {\n\t\t\t\tnextContent();\n\t\t\t\tif (length >= contentItemLength) {\n\t\t\t\t\tresult.push(contentItem);\n\t\t\t\t\tlength -= contentItemLength;\n\t\t\t\t\tcontentPosition = contentItemLength;\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(\n\t\t\t\t\t\tBuffer.from(contentItem.buffer, contentItem.byteOffset, length)\n\t\t\t\t\t);\n\t\t\t\t\tcontentPosition += length;\n\t\t\t\t\tlength = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n};\n\n/**\n * @typedef {BufferSerializableType[]} DeserializedType\n * @typedef {true} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\nclass FileMiddleware extends SerializerMiddleware {\n\t/**\n\t * @param {IntermediateFileSystem} fs filesystem\n\t * @param {string | Hash} hashFunction hash function to use\n\t */\n\tconstructor(fs, hashFunction = \"md4\") {\n\t\tsuper();\n\t\tthis.fs = fs;\n\t\tthis._hashFunction = hashFunction;\n\t}\n\t/**\n\t * @param {DeserializedType} data data\n\t * @param {Object} context context object\n\t * @returns {SerializedType|Promise<SerializedType>} serialized data\n\t */\n\tserialize(data, context) {\n\t\tconst { filename, extension = \"\" } = context;\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tmkdirp(this.fs, dirname(this.fs, filename), err => {\n\t\t\t\tif (err) return reject(err);\n\n\t\t\t\t// It's important that we don't touch existing files during serialization\n\t\t\t\t// because serialize may read existing files (when deserializing)\n\t\t\t\tconst allWrittenFiles = new Set();\n\t\t\t\tconst writeFile = async (name, content, size) => {\n\t\t\t\t\tconst file = name\n\t\t\t\t\t\t? join(this.fs, filename, `../${name}${extension}`)\n\t\t\t\t\t\t: filename;\n\t\t\t\t\tawait new Promise((resolve, reject) => {\n\t\t\t\t\t\tlet stream = this.fs.createWriteStream(file + \"_\");\n\t\t\t\t\t\tlet compression;\n\t\t\t\t\t\tif (file.endsWith(\".gz\")) {\n\t\t\t\t\t\t\tcompression = createGzip({\n\t\t\t\t\t\t\t\tchunkSize: COMPRESSION_CHUNK_SIZE,\n\t\t\t\t\t\t\t\tlevel: zConstants.Z_BEST_SPEED\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else if (file.endsWith(\".br\")) {\n\t\t\t\t\t\t\tcompression = createBrotliCompress({\n\t\t\t\t\t\t\t\tchunkSize: COMPRESSION_CHUNK_SIZE,\n\t\t\t\t\t\t\t\tparams: {\n\t\t\t\t\t\t\t\t\t[zConstants.BROTLI_PARAM_MODE]: zConstants.BROTLI_MODE_TEXT,\n\t\t\t\t\t\t\t\t\t[zConstants.BROTLI_PARAM_QUALITY]: 2,\n\t\t\t\t\t\t\t\t\t[zConstants.BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING]: true,\n\t\t\t\t\t\t\t\t\t[zConstants.BROTLI_PARAM_SIZE_HINT]: size\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (compression) {\n\t\t\t\t\t\t\tpipeline(compression, stream, reject);\n\t\t\t\t\t\t\tstream = compression;\n\t\t\t\t\t\t\tstream.on(\"finish\", () => resolve());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstream.on(\"error\", err => reject(err));\n\t\t\t\t\t\t\tstream.on(\"finish\", () => resolve());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// split into chunks for WRITE_LIMIT_CHUNK size\n\t\t\t\t\t\tconst chunks = [];\n\t\t\t\t\t\tfor (const b of content) {\n\t\t\t\t\t\t\tif (b.length < WRITE_LIMIT_CHUNK) {\n\t\t\t\t\t\t\t\tchunks.push(b);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < b.length; i += WRITE_LIMIT_CHUNK) {\n\t\t\t\t\t\t\t\t\tchunks.push(b.slice(i, i + WRITE_LIMIT_CHUNK));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst len = chunks.length;\n\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\tconst batchWrite = err => {\n\t\t\t\t\t\t\t// will be handled in \"on\" error handler\n\t\t\t\t\t\t\tif (err) return;\n\n\t\t\t\t\t\t\tif (i === len) {\n\t\t\t\t\t\t\t\tstream.end();\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// queue up a batch of chunks up to the write limit\n\t\t\t\t\t\t\t// end is exclusive\n\t\t\t\t\t\t\tlet end = i;\n\t\t\t\t\t\t\tlet sum = chunks[end++].length;\n\t\t\t\t\t\t\twhile (end < len) {\n\t\t\t\t\t\t\t\tsum += chunks[end].length;\n\t\t\t\t\t\t\t\tif (sum > WRITE_LIMIT_TOTAL) break;\n\t\t\t\t\t\t\t\tend++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhile (i < end - 1) {\n\t\t\t\t\t\t\t\tstream.write(chunks[i++]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstream.write(chunks[i++], batchWrite);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbatchWrite();\n\t\t\t\t\t});\n\t\t\t\t\tif (name) allWrittenFiles.add(file);\n\t\t\t\t};\n\n\t\t\t\tresolve(\n\t\t\t\t\tserialize(this, data, false, writeFile, this._hashFunction).then(\n\t\t\t\t\t\tasync ({ backgroundJob }) => {\n\t\t\t\t\t\t\tawait backgroundJob;\n\n\t\t\t\t\t\t\t// Rename the index file to disallow access during inconsistent file state\n\t\t\t\t\t\t\tawait new Promise(resolve =>\n\t\t\t\t\t\t\t\tthis.fs.rename(filename, filename + \".old\", err => {\n\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// update all written files\n\t\t\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\t\t\tArray.from(\n\t\t\t\t\t\t\t\t\tallWrittenFiles,\n\t\t\t\t\t\t\t\t\tfile =>\n\t\t\t\t\t\t\t\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\t\t\t\t\t\t\t\tthis.fs.rename(file + \"_\", file, err => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (err) return reject(err);\n\t\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// As final step automatically update the index file to have a consistent pack again\n\t\t\t\t\t\t\tawait new Promise(resolve => {\n\t\t\t\t\t\t\t\tthis.fs.rename(filename + \"_\", filename, err => {\n\t\t\t\t\t\t\t\t\tif (err) return reject(err);\n\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn /** @type {true} */ (true);\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {SerializedType} data data\n\t * @param {Object} context context object\n\t * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n\t */\n\tdeserialize(data, context) {\n\t\tconst { filename, extension = \"\" } = context;\n\t\tconst readFile = name =>\n\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\tconst file = name\n\t\t\t\t\t? join(this.fs, filename, `../${name}${extension}`)\n\t\t\t\t\t: filename;\n\t\t\t\tthis.fs.stat(file, (err, stats) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlet remaining = /** @type {number} */ (stats.size);\n\t\t\t\t\tlet currentBuffer;\n\t\t\t\t\tlet currentBufferUsed;\n\t\t\t\t\tconst buf = [];\n\t\t\t\t\tlet decompression;\n\t\t\t\t\tif (file.endsWith(\".gz\")) {\n\t\t\t\t\t\tdecompression = createGunzip({\n\t\t\t\t\t\t\tchunkSize: DECOMPRESSION_CHUNK_SIZE\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (file.endsWith(\".br\")) {\n\t\t\t\t\t\tdecompression = createBrotliDecompress({\n\t\t\t\t\t\t\tchunkSize: DECOMPRESSION_CHUNK_SIZE\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (decompression) {\n\t\t\t\t\t\tlet newResolve, newReject;\n\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\tPromise.all([\n\t\t\t\t\t\t\t\tnew Promise((rs, rj) => {\n\t\t\t\t\t\t\t\t\tnewResolve = rs;\n\t\t\t\t\t\t\t\t\tnewReject = rj;\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\t\t\t\t\t\tdecompression.on(\"data\", chunk => buf.push(chunk));\n\t\t\t\t\t\t\t\t\tdecompression.on(\"end\", () => resolve());\n\t\t\t\t\t\t\t\t\tdecompression.on(\"error\", err => reject(err));\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t]).then(() => buf)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresolve = newResolve;\n\t\t\t\t\t\treject = newReject;\n\t\t\t\t\t}\n\t\t\t\t\tthis.fs.open(file, \"r\", (err, fd) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst read = () => {\n\t\t\t\t\t\t\tif (currentBuffer === undefined) {\n\t\t\t\t\t\t\t\tcurrentBuffer = Buffer.allocUnsafeSlow(\n\t\t\t\t\t\t\t\t\tMath.min(\n\t\t\t\t\t\t\t\t\t\tconstants.MAX_LENGTH,\n\t\t\t\t\t\t\t\t\t\tremaining,\n\t\t\t\t\t\t\t\t\t\tdecompression ? DECOMPRESSION_CHUNK_SIZE : Infinity\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcurrentBufferUsed = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet readBuffer = currentBuffer;\n\t\t\t\t\t\t\tlet readOffset = currentBufferUsed;\n\t\t\t\t\t\t\tlet readLength = currentBuffer.length - currentBufferUsed;\n\t\t\t\t\t\t\t// values passed to fs.read must be valid int32 values\n\t\t\t\t\t\t\tif (readOffset > 0x7fffffff) {\n\t\t\t\t\t\t\t\treadBuffer = currentBuffer.slice(readOffset);\n\t\t\t\t\t\t\t\treadOffset = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (readLength > 0x7fffffff) {\n\t\t\t\t\t\t\t\treadLength = 0x7fffffff;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.fs.read(\n\t\t\t\t\t\t\t\tfd,\n\t\t\t\t\t\t\t\treadBuffer,\n\t\t\t\t\t\t\t\treadOffset,\n\t\t\t\t\t\t\t\treadLength,\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t(err, bytesRead) => {\n\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\tthis.fs.close(fd, () => {\n\t\t\t\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcurrentBufferUsed += bytesRead;\n\t\t\t\t\t\t\t\t\tremaining -= bytesRead;\n\t\t\t\t\t\t\t\t\tif (currentBufferUsed === currentBuffer.length) {\n\t\t\t\t\t\t\t\t\t\tif (decompression) {\n\t\t\t\t\t\t\t\t\t\t\tdecompression.write(currentBuffer);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tbuf.push(currentBuffer);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcurrentBuffer = undefined;\n\t\t\t\t\t\t\t\t\t\tif (remaining === 0) {\n\t\t\t\t\t\t\t\t\t\t\tif (decompression) {\n\t\t\t\t\t\t\t\t\t\t\t\tdecompression.end();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tthis.fs.close(fd, err => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tresolve(buf);\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tread();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tread();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\treturn deserialize(this, false, readFile);\n\t}\n}\n\nmodule.exports = FileMiddleware;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}