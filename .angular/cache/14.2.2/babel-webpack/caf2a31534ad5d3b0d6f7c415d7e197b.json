{"ast":null,"code":"/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.URI = global.URI || {});\n})(this, function (exports) {\n  'use strict';\n\n  function merge() {\n    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {\n      sets[_key] = arguments[_key];\n    }\n\n    if (sets.length > 1) {\n      sets[0] = sets[0].slice(0, -1);\n      var xl = sets.length - 1;\n\n      for (var x = 1; x < xl; ++x) {\n        sets[x] = sets[x].slice(1, -1);\n      }\n\n      sets[xl] = sets[xl].slice(1);\n      return sets.join('');\n    } else {\n      return sets[0];\n    }\n  }\n\n  function subexp(str) {\n    return \"(?:\" + str + \")\";\n  }\n\n  function typeOf(o) {\n    return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n  }\n\n  function toUpperCase(str) {\n    return str.toUpperCase();\n  }\n\n  function toArray(obj) {\n    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];\n  }\n\n  function assign(target, source) {\n    var obj = target;\n\n    if (source) {\n      for (var key in source) {\n        obj[key] = source[key];\n      }\n    }\n\n    return obj;\n  }\n\n  function buildExps(isIRI) {\n    var ALPHA$$ = \"[A-Za-z]\",\n        CR$ = \"[\\\\x0D]\",\n        DIGIT$$ = \"[0-9]\",\n        DQUOTE$$ = \"[\\\\x22]\",\n        HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),\n        //case-insensitive\n    LF$$ = \"[\\\\x0A]\",\n        SP$$ = \"[\\\\x20]\",\n        PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),\n        //expanded\n    GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n        SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n        UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",\n        //subset, excludes bidi control characters\n    IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",\n        //subset\n    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n        USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n        DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n        DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),\n        //relaxed parsing rules\n    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n        H16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n        LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n        IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$),\n        //                           6( h16 \":\" ) ls32\n    IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$),\n        //                      \"::\" 5( h16 \":\" ) ls32\n    IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$),\n        //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$),\n        //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$),\n        //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$),\n        //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$),\n        //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$),\n        //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"),\n        //[ *6( h16 \":\" ) h16 ] \"::\"\n    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n        ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),\n        //RFC 6874\n    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),\n        //RFC 6874\n    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),\n        //RFC 6874, with relaxed parsing rules\n    IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n        IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),\n        //RFC 6874\n    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n        HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n        PORT$ = subexp(DIGIT$$ + \"*\"),\n        AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n        PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n        SEGMENT$ = subexp(PCHAR$ + \"*\"),\n        SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n        PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n        PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),\n        //simplified\n    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n        PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n        FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n        HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n        RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n        ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n        GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n        SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n    return {\n      NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n      NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n      NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n      NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n      NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n      NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n      NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n      ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n      UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n      OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n      PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n      IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n      IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n\n    };\n  }\n\n  var URI_PROTOCOL = buildExps(false);\n  var IRI_PROTOCOL = buildExps(true);\n\n  var slicedToArray = function () {\n    function sliceIterator(arr, i) {\n      var _arr = [];\n      var _n = true;\n      var _d = false;\n      var _e = undefined;\n\n      try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);\n\n          if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;\n        _e = err;\n      } finally {\n        try {\n          if (!_n && _i[\"return\"]) _i[\"return\"]();\n        } finally {\n          if (_d) throw _e;\n        }\n      }\n\n      return _arr;\n    }\n\n    return function (arr, i) {\n      if (Array.isArray(arr)) {\n        return arr;\n      } else if (Symbol.iterator in Object(arr)) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n    };\n  }();\n\n  var toConsumableArray = function (arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  };\n  /** Highest positive signed 32-bit float value */\n\n\n  var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n  /** Bootstring parameters */\n\n  var base = 36;\n  var tMin = 1;\n  var tMax = 26;\n  var skew = 38;\n  var damp = 700;\n  var initialBias = 72;\n  var initialN = 128; // 0x80\n\n  var delimiter = '-'; // '\\x2D'\n\n  /** Regular expressions */\n\n  var regexPunycode = /^xn--/;\n  var regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\n\n  var regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n  /** Error messages */\n\n  var errors = {\n    'overflow': 'Overflow: input needs wider integers to process',\n    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n    'invalid-input': 'Invalid input'\n  };\n  /** Convenience shortcuts */\n\n  var baseMinusTMin = base - tMin;\n  var floor = Math.floor;\n  var stringFromCharCode = String.fromCharCode;\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * A generic error utility function.\n   * @private\n   * @param {String} type The error type.\n   * @returns {Error} Throws a `RangeError` with the applicable error message.\n   */\n\n  function error$1(type) {\n    throw new RangeError(errors[type]);\n  }\n  /**\n   * A generic `Array#map` utility function.\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} callback The function that gets called for every array\n   * item.\n   * @returns {Array} A new array of values returned by the callback function.\n   */\n\n\n  function map(array, fn) {\n    var result = [];\n    var length = array.length;\n\n    while (length--) {\n      result[length] = fn(array[length]);\n    }\n\n    return result;\n  }\n  /**\n   * A simple `Array#map`-like wrapper to work with domain name strings or email\n   * addresses.\n   * @private\n   * @param {String} domain The domain name or email address.\n   * @param {Function} callback The function that gets called for every\n   * character.\n   * @returns {Array} A new string of characters returned by the callback\n   * function.\n   */\n\n\n  function mapDomain(string, fn) {\n    var parts = string.split('@');\n    var result = '';\n\n    if (parts.length > 1) {\n      // In email addresses, only the domain name should be punycoded. Leave\n      // the local part (i.e. everything up to `@`) intact.\n      result = parts[0] + '@';\n      string = parts[1];\n    } // Avoid `split(regex)` for IE8 compatibility. See #17.\n\n\n    string = string.replace(regexSeparators, '\\x2E');\n    var labels = string.split('.');\n    var encoded = map(labels, fn).join('.');\n    return result + encoded;\n  }\n  /**\n   * Creates an array containing the numeric code points of each Unicode\n   * character in the string. While JavaScript uses UCS-2 internally,\n   * this function will convert a pair of surrogate halves (each of which\n   * UCS-2 exposes as separate characters) into a single code point,\n   * matching UTF-16.\n   * @see `punycode.ucs2.encode`\n   * @see <https://mathiasbynens.be/notes/javascript-encoding>\n   * @memberOf punycode.ucs2\n   * @name decode\n   * @param {String} string The Unicode input string (UCS-2).\n   * @returns {Array} The new array of code points.\n   */\n\n\n  function ucs2decode(string) {\n    var output = [];\n    var counter = 0;\n    var length = string.length;\n\n    while (counter < length) {\n      var value = string.charCodeAt(counter++);\n\n      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n        // It's a high surrogate, and there is a next character.\n        var extra = string.charCodeAt(counter++);\n\n        if ((extra & 0xFC00) == 0xDC00) {\n          // Low surrogate.\n          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n        } else {\n          // It's an unmatched surrogate; only append this code unit, in case the\n          // next code unit is the high surrogate of a surrogate pair.\n          output.push(value);\n          counter--;\n        }\n      } else {\n        output.push(value);\n      }\n    }\n\n    return output;\n  }\n  /**\n   * Creates a string based on an array of numeric code points.\n   * @see `punycode.ucs2.decode`\n   * @memberOf punycode.ucs2\n   * @name encode\n   * @param {Array} codePoints The array of numeric code points.\n   * @returns {String} The new Unicode string (UCS-2).\n   */\n\n\n  var ucs2encode = function ucs2encode(array) {\n    return String.fromCodePoint.apply(String, toConsumableArray(array));\n  };\n  /**\n   * Converts a basic code point into a digit/integer.\n   * @see `digitToBasic()`\n   * @private\n   * @param {Number} codePoint The basic numeric code point value.\n   * @returns {Number} The numeric value of a basic code point (for use in\n   * representing integers) in the range `0` to `base - 1`, or `base` if\n   * the code point does not represent a value.\n   */\n\n\n  var basicToDigit = function basicToDigit(codePoint) {\n    if (codePoint - 0x30 < 0x0A) {\n      return codePoint - 0x16;\n    }\n\n    if (codePoint - 0x41 < 0x1A) {\n      return codePoint - 0x41;\n    }\n\n    if (codePoint - 0x61 < 0x1A) {\n      return codePoint - 0x61;\n    }\n\n    return base;\n  };\n  /**\n   * Converts a digit/integer into a basic code point.\n   * @see `basicToDigit()`\n   * @private\n   * @param {Number} digit The numeric value of a basic code point.\n   * @returns {Number} The basic code point whose value (when used for\n   * representing integers) is `digit`, which needs to be in the range\n   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n   * used; else, the lowercase form is used. The behavior is undefined\n   * if `flag` is non-zero and `digit` has no uppercase form.\n   */\n\n\n  var digitToBasic = function digitToBasic(digit, flag) {\n    //  0..25 map to ASCII a..z or A..Z\n    // 26..35 map to ASCII 0..9\n    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n  };\n  /**\n   * Bias adaptation function as per section 3.4 of RFC 3492.\n   * https://tools.ietf.org/html/rfc3492#section-3.4\n   * @private\n   */\n\n\n  var adapt = function adapt(delta, numPoints, firstTime) {\n    var k = 0;\n    delta = firstTime ? floor(delta / damp) : delta >> 1;\n    delta += floor(delta / numPoints);\n\n    for (;\n    /* no initialization */\n    delta > baseMinusTMin * tMax >> 1; k += base) {\n      delta = floor(delta / baseMinusTMin);\n    }\n\n    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n  };\n  /**\n   * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n   * symbols.\n   * @memberOf punycode\n   * @param {String} input The Punycode string of ASCII-only symbols.\n   * @returns {String} The resulting string of Unicode symbols.\n   */\n\n\n  var decode = function decode(input) {\n    // Don't use UCS-2.\n    var output = [];\n    var inputLength = input.length;\n    var i = 0;\n    var n = initialN;\n    var bias = initialBias; // Handle the basic code points: let `basic` be the number of input code\n    // points before the last delimiter, or `0` if there is none, then copy\n    // the first basic code points to the output.\n\n    var basic = input.lastIndexOf(delimiter);\n\n    if (basic < 0) {\n      basic = 0;\n    }\n\n    for (var j = 0; j < basic; ++j) {\n      // if it's not a basic code point\n      if (input.charCodeAt(j) >= 0x80) {\n        error$1('not-basic');\n      }\n\n      output.push(input.charCodeAt(j));\n    } // Main decoding loop: start just after the last delimiter if any basic code\n    // points were copied; start at the beginning otherwise.\n\n\n    for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;)\n    /* no final expression */\n    {\n      // `index` is the index of the next character to be consumed.\n      // Decode a generalized variable-length integer into `delta`,\n      // which gets added to `i`. The overflow checking is easier\n      // if we increase `i` as we go, then subtract off its starting\n      // value at the end to obtain `delta`.\n      var oldi = i;\n\n      for (var w = 1, k = base;;\n      /* no condition */\n      k += base) {\n        if (index >= inputLength) {\n          error$1('invalid-input');\n        }\n\n        var digit = basicToDigit(input.charCodeAt(index++));\n\n        if (digit >= base || digit > floor((maxInt - i) / w)) {\n          error$1('overflow');\n        }\n\n        i += digit * w;\n        var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n        if (digit < t) {\n          break;\n        }\n\n        var baseMinusT = base - t;\n\n        if (w > floor(maxInt / baseMinusT)) {\n          error$1('overflow');\n        }\n\n        w *= baseMinusT;\n      }\n\n      var out = output.length + 1;\n      bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,\n      // incrementing `n` each time, so we'll fix that now:\n\n      if (floor(i / out) > maxInt - n) {\n        error$1('overflow');\n      }\n\n      n += floor(i / out);\n      i %= out; // Insert `n` at position `i` of the output.\n\n      output.splice(i++, 0, n);\n    }\n\n    return String.fromCodePoint.apply(String, output);\n  };\n  /**\n   * Converts a string of Unicode symbols (e.g. a domain name label) to a\n   * Punycode string of ASCII-only symbols.\n   * @memberOf punycode\n   * @param {String} input The string of Unicode symbols.\n   * @returns {String} The resulting Punycode string of ASCII-only symbols.\n   */\n\n\n  var encode = function encode(input) {\n    var output = []; // Convert the input in UCS-2 to an array of Unicode code points.\n\n    input = ucs2decode(input); // Cache the length.\n\n    var inputLength = input.length; // Initialize the state.\n\n    var n = initialN;\n    var delta = 0;\n    var bias = initialBias; // Handle the basic code points.\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _currentValue2 = _step.value;\n\n        if (_currentValue2 < 0x80) {\n          output.push(stringFromCharCode(_currentValue2));\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var basicLength = output.length;\n    var handledCPCount = basicLength; // `handledCPCount` is the number of code points that have been handled;\n    // `basicLength` is the number of basic code points.\n    // Finish the basic string with a delimiter unless it's empty.\n\n    if (basicLength) {\n      output.push(delimiter);\n    } // Main encoding loop:\n\n\n    while (handledCPCount < inputLength) {\n      // All non-basic code points < n have been handled already. Find the next\n      // larger one:\n      var m = maxInt;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var currentValue = _step2.value;\n\n          if (currentValue >= n && currentValue < m) {\n            m = currentValue;\n          }\n        } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n        // but guard against overflow.\n\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var handledCPCountPlusOne = handledCPCount + 1;\n\n      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n        error$1('overflow');\n      }\n\n      delta += (m - n) * handledCPCountPlusOne;\n      n = m;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _currentValue = _step3.value;\n\n          if (_currentValue < n && ++delta > maxInt) {\n            error$1('overflow');\n          }\n\n          if (_currentValue == n) {\n            // Represent delta as a generalized variable-length integer.\n            var q = delta;\n\n            for (var k = base;;\n            /* no condition */\n            k += base) {\n              var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n              if (q < t) {\n                break;\n              }\n\n              var qMinusT = q - t;\n              var baseMinusT = base - t;\n              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n              q = floor(qMinusT / baseMinusT);\n            }\n\n            output.push(stringFromCharCode(digitToBasic(q, 0)));\n            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n            delta = 0;\n            ++handledCPCount;\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      ++delta;\n      ++n;\n    }\n\n    return output.join('');\n  };\n  /**\n   * Converts a Punycode string representing a domain name or an email address\n   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n   * it doesn't matter if you call it on a string that has already been\n   * converted to Unicode.\n   * @memberOf punycode\n   * @param {String} input The Punycoded domain name or email address to\n   * convert to Unicode.\n   * @returns {String} The Unicode representation of the given Punycode\n   * string.\n   */\n\n\n  var toUnicode = function toUnicode(input) {\n    return mapDomain(input, function (string) {\n      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n    });\n  };\n  /**\n   * Converts a Unicode string representing a domain name or an email address to\n   * Punycode. Only the non-ASCII parts of the domain name will be converted,\n   * i.e. it doesn't matter if you call it with a domain that's already in\n   * ASCII.\n   * @memberOf punycode\n   * @param {String} input The domain name or email address to convert, as a\n   * Unicode string.\n   * @returns {String} The Punycode representation of the given domain name or\n   * email address.\n   */\n\n\n  var toASCII = function toASCII(input) {\n    return mapDomain(input, function (string) {\n      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n    });\n  };\n  /*--------------------------------------------------------------------------*/\n\n  /** Define the public API */\n\n\n  var punycode = {\n    /**\n     * A string representing the current Punycode.js version number.\n     * @memberOf punycode\n     * @type String\n     */\n    'version': '2.1.0',\n\n    /**\n     * An object of methods to convert from JavaScript's internal character\n     * representation (UCS-2) to Unicode code points, and back.\n     * @see <https://mathiasbynens.be/notes/javascript-encoding>\n     * @memberOf punycode\n     * @type Object\n     */\n    'ucs2': {\n      'decode': ucs2decode,\n      'encode': ucs2encode\n    },\n    'decode': decode,\n    'encode': encode,\n    'toASCII': toASCII,\n    'toUnicode': toUnicode\n  };\n  /**\n   * URI.js\n   *\n   * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n   * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n   * @see http://github.com/garycourt/uri-js\n   */\n\n  /**\n   * Copyright 2011 Gary Court. All rights reserved.\n   *\n   * Redistribution and use in source and binary forms, with or without modification, are\n   * permitted provided that the following conditions are met:\n   *\n   *    1. Redistributions of source code must retain the above copyright notice, this list of\n   *       conditions and the following disclaimer.\n   *\n   *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n   *       of conditions and the following disclaimer in the documentation and/or other materials\n   *       provided with the distribution.\n   *\n   * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n   * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n   * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n   * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n   * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n   *\n   * The views and conclusions contained in the software and documentation are those of the\n   * authors and should not be interpreted as representing official policies, either expressed\n   * or implied, of Gary Court.\n   */\n\n  var SCHEMES = {};\n\n  function pctEncChar(chr) {\n    var c = chr.charCodeAt(0);\n    var e = void 0;\n    if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n    return e;\n  }\n\n  function pctDecChars(str) {\n    var newStr = \"\";\n    var i = 0;\n    var il = str.length;\n\n    while (i < il) {\n      var c = parseInt(str.substr(i + 1, 2), 16);\n\n      if (c < 128) {\n        newStr += String.fromCharCode(c);\n        i += 3;\n      } else if (c >= 194 && c < 224) {\n        if (il - i >= 6) {\n          var c2 = parseInt(str.substr(i + 4, 2), 16);\n          newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n        } else {\n          newStr += str.substr(i, 6);\n        }\n\n        i += 6;\n      } else if (c >= 224) {\n        if (il - i >= 9) {\n          var _c = parseInt(str.substr(i + 4, 2), 16);\n\n          var c3 = parseInt(str.substr(i + 7, 2), 16);\n          newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n        } else {\n          newStr += str.substr(i, 9);\n        }\n\n        i += 9;\n      } else {\n        newStr += str.substr(i, 3);\n        i += 3;\n      }\n    }\n\n    return newStr;\n  }\n\n  function _normalizeComponentEncoding(components, protocol) {\n    function decodeUnreserved(str) {\n      var decStr = pctDecChars(str);\n      return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n    }\n\n    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    return components;\n  }\n\n  function _stripLeadingZeros(str) {\n    return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n  }\n\n  function _normalizeIPv4(host, protocol) {\n    var matches = host.match(protocol.IPV4ADDRESS) || [];\n\n    var _matches = slicedToArray(matches, 2),\n        address = _matches[1];\n\n    if (address) {\n      return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n    } else {\n      return host;\n    }\n  }\n\n  function _normalizeIPv6(host, protocol) {\n    var matches = host.match(protocol.IPV6ADDRESS) || [];\n\n    var _matches2 = slicedToArray(matches, 3),\n        address = _matches2[1],\n        zone = _matches2[2];\n\n    if (address) {\n      var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),\n          _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),\n          last = _address$toLowerCase$2[0],\n          first = _address$toLowerCase$2[1];\n\n      var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n      var lastFields = last.split(\":\").map(_stripLeadingZeros);\n      var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n      var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n      var lastFieldsStart = lastFields.length - fieldCount;\n      var fields = Array(fieldCount);\n\n      for (var x = 0; x < fieldCount; ++x) {\n        fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n      }\n\n      if (isLastFieldIPv4Address) {\n        fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n      }\n\n      var allZeroFields = fields.reduce(function (acc, field, index) {\n        if (!field || field === \"0\") {\n          var lastLongest = acc[acc.length - 1];\n\n          if (lastLongest && lastLongest.index + lastLongest.length === index) {\n            lastLongest.length++;\n          } else {\n            acc.push({\n              index: index,\n              length: 1\n            });\n          }\n        }\n\n        return acc;\n      }, []);\n      var longestZeroFields = allZeroFields.sort(function (a, b) {\n        return b.length - a.length;\n      })[0];\n      var newHost = void 0;\n\n      if (longestZeroFields && longestZeroFields.length > 1) {\n        var newFirst = fields.slice(0, longestZeroFields.index);\n        var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n        newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n      } else {\n        newHost = fields.join(\":\");\n      }\n\n      if (zone) {\n        newHost += \"%\" + zone;\n      }\n\n      return newHost;\n    } else {\n      return host;\n    }\n  }\n\n  var URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\n  var NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\n\n  function parse(uriString) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var components = {};\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n    var matches = uriString.match(URI_PARSE);\n\n    if (matches) {\n      if (NO_MATCH_IS_UNDEFINED) {\n        //store each component\n        components.scheme = matches[1];\n        components.userinfo = matches[3];\n        components.host = matches[4];\n        components.port = parseInt(matches[5], 10);\n        components.path = matches[6] || \"\";\n        components.query = matches[7];\n        components.fragment = matches[8]; //fix port number\n\n        if (isNaN(components.port)) {\n          components.port = matches[5];\n        }\n      } else {\n        //IE FIX for improper RegExp matching\n        //store each component\n        components.scheme = matches[1] || undefined;\n        components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n        components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n        components.port = parseInt(matches[5], 10);\n        components.path = matches[6] || \"\";\n        components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n        components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined; //fix port number\n\n        if (isNaN(components.port)) {\n          components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n        }\n      }\n\n      if (components.host) {\n        //normalize IP hosts\n        components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n      } //determine reference type\n\n\n      if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n        components.reference = \"same-document\";\n      } else if (components.scheme === undefined) {\n        components.reference = \"relative\";\n      } else if (components.fragment === undefined) {\n        components.reference = \"absolute\";\n      } else {\n        components.reference = \"uri\";\n      } //check for reference errors\n\n\n      if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n        components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n      } //find scheme handler\n\n\n      var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()]; //check if scheme can't handle IRIs\n\n      if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n        //if host component is a domain name\n        if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n          //convert Unicode IDN -> ASCII IDN\n          try {\n            components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n          } catch (e) {\n            components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n          }\n        } //convert IRI -> URI\n\n\n        _normalizeComponentEncoding(components, URI_PROTOCOL);\n      } else {\n        //normalize encodings\n        _normalizeComponentEncoding(components, protocol);\n      } //perform scheme specific parsing\n\n\n      if (schemeHandler && schemeHandler.parse) {\n        schemeHandler.parse(components, options);\n      }\n    } else {\n      components.error = components.error || \"URI can not be parsed.\";\n    }\n\n    return components;\n  }\n\n  function _recomposeAuthority(components, options) {\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n\n    if (components.userinfo !== undefined) {\n      uriTokens.push(components.userinfo);\n      uriTokens.push(\"@\");\n    }\n\n    if (components.host !== undefined) {\n      //normalize IP hosts, add brackets and escape zone separator for IPv6\n      uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {\n        return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n      }));\n    }\n\n    if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n      uriTokens.push(\":\");\n      uriTokens.push(String(components.port));\n    }\n\n    return uriTokens.length ? uriTokens.join(\"\") : undefined;\n  }\n\n  var RDS1 = /^\\.\\.?\\//;\n  var RDS2 = /^\\/\\.(\\/|$)/;\n  var RDS3 = /^\\/\\.\\.(\\/|$)/;\n  var RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n\n  function removeDotSegments(input) {\n    var output = [];\n\n    while (input.length) {\n      if (input.match(RDS1)) {\n        input = input.replace(RDS1, \"\");\n      } else if (input.match(RDS2)) {\n        input = input.replace(RDS2, \"/\");\n      } else if (input.match(RDS3)) {\n        input = input.replace(RDS3, \"/\");\n        output.pop();\n      } else if (input === \".\" || input === \"..\") {\n        input = \"\";\n      } else {\n        var im = input.match(RDS5);\n\n        if (im) {\n          var s = im[0];\n          input = input.slice(s.length);\n          output.push(s);\n        } else {\n          throw new Error(\"Unexpected dot segment condition\");\n        }\n      }\n    }\n\n    return output.join(\"\");\n  }\n\n  function serialize(components) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = []; //find scheme handler\n\n    var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()]; //perform scheme specific serialization\n\n    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n\n    if (components.host) {\n      //if host component is an IPv6 address\n      if (protocol.IPV6ADDRESS.test(components.host)) {} //TODO: normalize IPv6 address as per RFC 5952\n      //if host component is a domain name\n      else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n        //convert IDN via punycode\n        try {\n          components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n        } catch (e) {\n          components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n        }\n      }\n    } //normalize encoding\n\n\n    _normalizeComponentEncoding(components, protocol);\n\n    if (options.reference !== \"suffix\" && components.scheme) {\n      uriTokens.push(components.scheme);\n      uriTokens.push(\":\");\n    }\n\n    var authority = _recomposeAuthority(components, options);\n\n    if (authority !== undefined) {\n      if (options.reference !== \"suffix\") {\n        uriTokens.push(\"//\");\n      }\n\n      uriTokens.push(authority);\n\n      if (components.path && components.path.charAt(0) !== \"/\") {\n        uriTokens.push(\"/\");\n      }\n    }\n\n    if (components.path !== undefined) {\n      var s = components.path;\n\n      if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n        s = removeDotSegments(s);\n      }\n\n      if (authority === undefined) {\n        s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n      }\n\n      uriTokens.push(s);\n    }\n\n    if (components.query !== undefined) {\n      uriTokens.push(\"?\");\n      uriTokens.push(components.query);\n    }\n\n    if (components.fragment !== undefined) {\n      uriTokens.push(\"#\");\n      uriTokens.push(components.fragment);\n    }\n\n    return uriTokens.join(\"\"); //merge tokens into a string\n  }\n\n  function resolveComponents(base, relative) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var skipNormalization = arguments[3];\n    var target = {};\n\n    if (!skipNormalization) {\n      base = parse(serialize(base, options), options); //normalize base components\n\n      relative = parse(serialize(relative, options), options); //normalize relative components\n    }\n\n    options = options || {};\n\n    if (!options.tolerant && relative.scheme) {\n      target.scheme = relative.scheme; //target.authority = relative.authority;\n\n      target.userinfo = relative.userinfo;\n      target.host = relative.host;\n      target.port = relative.port;\n      target.path = removeDotSegments(relative.path || \"\");\n      target.query = relative.query;\n    } else {\n      if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n        //target.authority = relative.authority;\n        target.userinfo = relative.userinfo;\n        target.host = relative.host;\n        target.port = relative.port;\n        target.path = removeDotSegments(relative.path || \"\");\n        target.query = relative.query;\n      } else {\n        if (!relative.path) {\n          target.path = base.path;\n\n          if (relative.query !== undefined) {\n            target.query = relative.query;\n          } else {\n            target.query = base.query;\n          }\n        } else {\n          if (relative.path.charAt(0) === \"/\") {\n            target.path = removeDotSegments(relative.path);\n          } else {\n            if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n              target.path = \"/\" + relative.path;\n            } else if (!base.path) {\n              target.path = relative.path;\n            } else {\n              target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n            }\n\n            target.path = removeDotSegments(target.path);\n          }\n\n          target.query = relative.query;\n        } //target.authority = base.authority;\n\n\n        target.userinfo = base.userinfo;\n        target.host = base.host;\n        target.port = base.port;\n      }\n\n      target.scheme = base.scheme;\n    }\n\n    target.fragment = relative.fragment;\n    return target;\n  }\n\n  function resolve(baseURI, relativeURI, options) {\n    var schemelessOptions = assign({\n      scheme: 'null'\n    }, options);\n    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n  }\n\n  function normalize(uri, options) {\n    if (typeof uri === \"string\") {\n      uri = serialize(parse(uri, options), options);\n    } else if (typeOf(uri) === \"object\") {\n      uri = parse(serialize(uri, options), options);\n    }\n\n    return uri;\n  }\n\n  function equal(uriA, uriB, options) {\n    if (typeof uriA === \"string\") {\n      uriA = serialize(parse(uriA, options), options);\n    } else if (typeOf(uriA) === \"object\") {\n      uriA = serialize(uriA, options);\n    }\n\n    if (typeof uriB === \"string\") {\n      uriB = serialize(parse(uriB, options), options);\n    } else if (typeOf(uriB) === \"object\") {\n      uriB = serialize(uriB, options);\n    }\n\n    return uriA === uriB;\n  }\n\n  function escapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n  }\n\n  function unescapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n  }\n\n  var handler = {\n    scheme: \"http\",\n    domainHost: true,\n    parse: function parse(components, options) {\n      //report missing host\n      if (!components.host) {\n        components.error = components.error || \"HTTP URIs must have a host.\";\n      }\n\n      return components;\n    },\n    serialize: function serialize(components, options) {\n      var secure = String(components.scheme).toLowerCase() === \"https\"; //normalize the default port\n\n      if (components.port === (secure ? 443 : 80) || components.port === \"\") {\n        components.port = undefined;\n      } //normalize the empty path\n\n\n      if (!components.path) {\n        components.path = \"/\";\n      } //NOTE: We do not parse query strings for HTTP URIs\n      //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n      //and not the HTTP spec.\n\n\n      return components;\n    }\n  };\n  var handler$1 = {\n    scheme: \"https\",\n    domainHost: handler.domainHost,\n    parse: handler.parse,\n    serialize: handler.serialize\n  };\n\n  function isSecure(wsComponents) {\n    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n  } //RFC 6455\n\n\n  var handler$2 = {\n    scheme: \"ws\",\n    domainHost: true,\n    parse: function parse(components, options) {\n      var wsComponents = components; //indicate if the secure flag is set\n\n      wsComponents.secure = isSecure(wsComponents); //construct resouce name\n\n      wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n      wsComponents.path = undefined;\n      wsComponents.query = undefined;\n      return wsComponents;\n    },\n    serialize: function serialize(wsComponents, options) {\n      //normalize the default port\n      if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n        wsComponents.port = undefined;\n      } //ensure scheme matches secure flag\n\n\n      if (typeof wsComponents.secure === 'boolean') {\n        wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';\n        wsComponents.secure = undefined;\n      } //reconstruct path from resource name\n\n\n      if (wsComponents.resourceName) {\n        var _wsComponents$resourc = wsComponents.resourceName.split('?'),\n            _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),\n            path = _wsComponents$resourc2[0],\n            query = _wsComponents$resourc2[1];\n\n        wsComponents.path = path && path !== '/' ? path : undefined;\n        wsComponents.query = query;\n        wsComponents.resourceName = undefined;\n      } //forbid fragment component\n\n\n      wsComponents.fragment = undefined;\n      return wsComponents;\n    }\n  };\n  var handler$3 = {\n    scheme: \"wss\",\n    domainHost: handler$2.domainHost,\n    parse: handler$2.parse,\n    serialize: handler$2.serialize\n  };\n  var O = {};\n  var isIRI = true; //RFC 3986\n\n  var UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\n  var HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\n\n  var PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n  //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n  //const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n  //const WSP$$ = \"[\\\\x20\\\\x09]\";\n  //const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n  //const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n  //const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n  //const WSP$$ = \"[\\\\x20\\\\x09]\";\n  //const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n  //const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n  //const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n  //const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\n\n  var ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n  var QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\n  var VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\n  var SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\n  var UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\n  var PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\n  var NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\n  var NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\n  var NOT_HFVALUE = NOT_HFNAME;\n\n  function decodeUnreserved(str) {\n    var decStr = pctDecChars(str);\n    return !decStr.match(UNRESERVED) ? str : decStr;\n  }\n\n  var handler$4 = {\n    scheme: \"mailto\",\n    parse: function parse$$1(components, options) {\n      var mailtoComponents = components;\n      var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n      mailtoComponents.path = undefined;\n\n      if (mailtoComponents.query) {\n        var unknownHeaders = false;\n        var headers = {};\n        var hfields = mailtoComponents.query.split(\"&\");\n\n        for (var x = 0, xl = hfields.length; x < xl; ++x) {\n          var hfield = hfields[x].split(\"=\");\n\n          switch (hfield[0]) {\n            case \"to\":\n              var toAddrs = hfield[1].split(\",\");\n\n              for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {\n                to.push(toAddrs[_x]);\n              }\n\n              break;\n\n            case \"subject\":\n              mailtoComponents.subject = unescapeComponent(hfield[1], options);\n              break;\n\n            case \"body\":\n              mailtoComponents.body = unescapeComponent(hfield[1], options);\n              break;\n\n            default:\n              unknownHeaders = true;\n              headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n              break;\n          }\n        }\n\n        if (unknownHeaders) mailtoComponents.headers = headers;\n      }\n\n      mailtoComponents.query = undefined;\n\n      for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {\n        var addr = to[_x2].split(\"@\");\n\n        addr[0] = unescapeComponent(addr[0]);\n\n        if (!options.unicodeSupport) {\n          //convert Unicode IDN -> ASCII IDN\n          try {\n            addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n          } catch (e) {\n            mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n          }\n        } else {\n          addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n        }\n\n        to[_x2] = addr.join(\"@\");\n      }\n\n      return mailtoComponents;\n    },\n    serialize: function serialize$$1(mailtoComponents, options) {\n      var components = mailtoComponents;\n      var to = toArray(mailtoComponents.to);\n\n      if (to) {\n        for (var x = 0, xl = to.length; x < xl; ++x) {\n          var toAddr = String(to[x]);\n          var atIdx = toAddr.lastIndexOf(\"@\");\n          var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n          var domain = toAddr.slice(atIdx + 1); //convert IDN via punycode\n\n          try {\n            domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n          } catch (e) {\n            components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n          }\n\n          to[x] = localPart + \"@\" + domain;\n        }\n\n        components.path = to.join(\",\");\n      }\n\n      var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n      if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n      if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n      var fields = [];\n\n      for (var name in headers) {\n        if (headers[name] !== O[name]) {\n          fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n        }\n      }\n\n      if (fields.length) {\n        components.query = fields.join(\"&\");\n      }\n\n      return components;\n    }\n  };\n  var URN_PARSE = /^([^\\:]+)\\:(.*)/; //RFC 2141\n\n  var handler$5 = {\n    scheme: \"urn\",\n    parse: function parse$$1(components, options) {\n      var matches = components.path && components.path.match(URN_PARSE);\n      var urnComponents = components;\n\n      if (matches) {\n        var scheme = options.scheme || urnComponents.scheme || \"urn\";\n        var nid = matches[1].toLowerCase();\n        var nss = matches[2];\n        var urnScheme = scheme + \":\" + (options.nid || nid);\n        var schemeHandler = SCHEMES[urnScheme];\n        urnComponents.nid = nid;\n        urnComponents.nss = nss;\n        urnComponents.path = undefined;\n\n        if (schemeHandler) {\n          urnComponents = schemeHandler.parse(urnComponents, options);\n        }\n      } else {\n        urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n      }\n\n      return urnComponents;\n    },\n    serialize: function serialize$$1(urnComponents, options) {\n      var scheme = options.scheme || urnComponents.scheme || \"urn\";\n      var nid = urnComponents.nid;\n      var urnScheme = scheme + \":\" + (options.nid || nid);\n      var schemeHandler = SCHEMES[urnScheme];\n\n      if (schemeHandler) {\n        urnComponents = schemeHandler.serialize(urnComponents, options);\n      }\n\n      var uriComponents = urnComponents;\n      var nss = urnComponents.nss;\n      uriComponents.path = (nid || options.nid) + \":\" + nss;\n      return uriComponents;\n    }\n  };\n  var UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/; //RFC 4122\n\n  var handler$6 = {\n    scheme: \"urn:uuid\",\n    parse: function parse(urnComponents, options) {\n      var uuidComponents = urnComponents;\n      uuidComponents.uuid = uuidComponents.nss;\n      uuidComponents.nss = undefined;\n\n      if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n        uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n      }\n\n      return uuidComponents;\n    },\n    serialize: function serialize(uuidComponents, options) {\n      var urnComponents = uuidComponents; //normalize UUID\n\n      urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n      return urnComponents;\n    }\n  };\n  SCHEMES[handler.scheme] = handler;\n  SCHEMES[handler$1.scheme] = handler$1;\n  SCHEMES[handler$2.scheme] = handler$2;\n  SCHEMES[handler$3.scheme] = handler$3;\n  SCHEMES[handler$4.scheme] = handler$4;\n  SCHEMES[handler$5.scheme] = handler$5;\n  SCHEMES[handler$6.scheme] = handler$6;\n  exports.SCHEMES = SCHEMES;\n  exports.pctEncChar = pctEncChar;\n  exports.pctDecChars = pctDecChars;\n  exports.parse = parse;\n  exports.removeDotSegments = removeDotSegments;\n  exports.serialize = serialize;\n  exports.resolveComponents = resolveComponents;\n  exports.resolve = resolve;\n  exports.normalize = normalize;\n  exports.equal = equal;\n  exports.escapeComponent = escapeComponent;\n  exports.unescapeComponent = unescapeComponent;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","URI","merge","_len","arguments","length","sets","Array","_key","slice","xl","x","join","subexp","str","typeOf","o","undefined","Object","prototype","toString","call","split","pop","shift","toLowerCase","toUpperCase","toArray","obj","setInterval","assign","target","source","key","buildExps","isIRI","ALPHA$$","CR$","DIGIT$$","DQUOTE$$","HEXDIG$$","LF$$","SP$$","PCT_ENCODED$","GEN_DELIMS$$","SUB_DELIMS$$","RESERVED$$","UCSCHAR$$","IPRIVATE$$","UNRESERVED$$","SCHEME$","USERINFO$","DEC_OCTET$","DEC_OCTET_RELAXED$","IPV4ADDRESS$","H16$","LS32$","IPV6ADDRESS1$","IPV6ADDRESS2$","IPV6ADDRESS3$","IPV6ADDRESS4$","IPV6ADDRESS5$","IPV6ADDRESS6$","IPV6ADDRESS7$","IPV6ADDRESS8$","IPV6ADDRESS9$","IPV6ADDRESS$","ZONEID$","IPV6ADDRZ$","IPV6ADDRZ_RELAXED$","IPVFUTURE$","IP_LITERAL$","REG_NAME$","HOST$","PORT$","AUTHORITY$","PCHAR$","SEGMENT$","SEGMENT_NZ$","SEGMENT_NZ_NC$","PATH_ABEMPTY$","PATH_ABSOLUTE$","PATH_NOSCHEME$","PATH_ROOTLESS$","PATH_EMPTY$","PATH$","QUERY$","FRAGMENT$","HIER_PART$","URI$","RELATIVE_PART$","RELATIVE$","URI_REFERENCE$","ABSOLUTE_URI$","GENERIC_REF$","RELATIVE_REF$","ABSOLUTE_REF$","SAMEDOC_REF$","AUTHORITY_REF$","NOT_SCHEME","RegExp","NOT_USERINFO","NOT_HOST","NOT_PATH","NOT_PATH_NOSCHEME","NOT_QUERY","NOT_FRAGMENT","ESCAPE","UNRESERVED","OTHER_CHARS","PCT_ENCODED","IPV4ADDRESS","IPV6ADDRESS","URI_PROTOCOL","IRI_PROTOCOL","slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","_i","Symbol","iterator","_s","next","done","push","value","err","isArray","TypeError","toConsumableArray","arr2","from","maxInt","base","tMin","tMax","skew","damp","initialBias","initialN","delimiter","regexPunycode","regexNonASCII","regexSeparators","errors","baseMinusTMin","floor","Math","stringFromCharCode","String","fromCharCode","error$1","type","RangeError","map","array","fn","result","mapDomain","string","parts","replace","labels","encoded","ucs2decode","output","counter","charCodeAt","extra","ucs2encode","fromCodePoint","apply","basicToDigit","codePoint","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","k","decode","input","inputLength","n","bias","basic","lastIndexOf","j","index","oldi","w","t","baseMinusT","out","splice","encode","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","_currentValue2","return","basicLength","handledCPCount","m","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","currentValue","handledCPCountPlusOne","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","_currentValue","q","qMinusT","toUnicode","test","toASCII","punycode","SCHEMES","pctEncChar","chr","c","e","pctDecChars","newStr","il","parseInt","substr","c2","_c","c3","_normalizeComponentEncoding","components","protocol","decodeUnreserved","decStr","match","scheme","userinfo","host","path","query","fragment","_stripLeadingZeros","_normalizeIPv4","matches","_matches","address","_normalizeIPv6","_matches2","zone","_address$toLowerCase$","reverse","_address$toLowerCase$2","last","first","firstFields","lastFields","isLastFieldIPv4Address","fieldCount","lastFieldsStart","fields","allZeroFields","reduce","acc","field","lastLongest","longestZeroFields","sort","a","b","newHost","newFirst","newLast","URI_PARSE","NO_MATCH_IS_UNDEFINED","parse","uriString","options","iri","reference","port","isNaN","indexOf","error","schemeHandler","unicodeSupport","domainHost","_recomposeAuthority","uriTokens","_","$1","$2","RDS1","RDS2","RDS3","RDS5","removeDotSegments","im","s","Error","serialize","authority","charAt","absolutePath","resolveComponents","relative","skipNormalization","tolerant","resolve","baseURI","relativeURI","schemelessOptions","normalize","uri","equal","uriA","uriB","escapeComponent","unescapeComponent","handler","secure","handler$1","isSecure","wsComponents","handler$2","resourceName","_wsComponents$resourc","_wsComponents$resourc2","handler$3","O","ATEXT$$","QTEXT$$","VCHAR$$","SOME_DELIMS$$","NOT_LOCAL_PART","NOT_HFNAME","NOT_HFVALUE","handler$4","parse$$1","mailtoComponents","to","unknownHeaders","headers","hfields","hfield","toAddrs","_x","_xl","subject","body","_x2","_xl2","addr","serialize$$1","toAddr","atIdx","localPart","domain","name","URN_PARSE","handler$5","urnComponents","nid","nss","urnScheme","uriComponents","UUID","handler$6","uuidComponents","uuid","defineProperty"],"sources":["D:/WebDev/dfproject/gp/node_modules/uri-js/dist/es5/uri.all.js"],"sourcesContent":["/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.URI = global.URI || {})));\n}(this, (function (exports) { 'use strict';\n\nfunction merge() {\n    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {\n        sets[_key] = arguments[_key];\n    }\n\n    if (sets.length > 1) {\n        sets[0] = sets[0].slice(0, -1);\n        var xl = sets.length - 1;\n        for (var x = 1; x < xl; ++x) {\n            sets[x] = sets[x].slice(1, -1);\n        }\n        sets[xl] = sets[xl].slice(1);\n        return sets.join('');\n    } else {\n        return sets[0];\n    }\n}\nfunction subexp(str) {\n    return \"(?:\" + str + \")\";\n}\nfunction typeOf(o) {\n    return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n}\nfunction toUpperCase(str) {\n    return str.toUpperCase();\n}\nfunction toArray(obj) {\n    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];\n}\nfunction assign(target, source) {\n    var obj = target;\n    if (source) {\n        for (var key in source) {\n            obj[key] = source[key];\n        }\n    }\n    return obj;\n}\n\nfunction buildExps(isIRI) {\n    var ALPHA$$ = \"[A-Za-z]\",\n        CR$ = \"[\\\\x0D]\",\n        DIGIT$$ = \"[0-9]\",\n        DQUOTE$$ = \"[\\\\x22]\",\n        HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),\n        //case-insensitive\n    LF$$ = \"[\\\\x0A]\",\n        SP$$ = \"[\\\\x20]\",\n        PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),\n        //expanded\n    GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n        SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n        UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",\n        //subset, excludes bidi control characters\n    IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",\n        //subset\n    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n        USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n        DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n        DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),\n        //relaxed parsing rules\n    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n        H16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n        LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n        IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$),\n        //                           6( h16 \":\" ) ls32\n    IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$),\n        //                      \"::\" 5( h16 \":\" ) ls32\n    IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$),\n        //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$),\n        //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$),\n        //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$),\n        //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$),\n        //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$),\n        //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"),\n        //[ *6( h16 \":\" ) h16 ] \"::\"\n    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n        ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),\n        //RFC 6874\n    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),\n        //RFC 6874\n    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),\n        //RFC 6874, with relaxed parsing rules\n    IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n        IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),\n        //RFC 6874\n    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n        HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n        PORT$ = subexp(DIGIT$$ + \"*\"),\n        AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n        PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n        SEGMENT$ = subexp(PCHAR$ + \"*\"),\n        SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n        PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n        PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),\n        //simplified\n    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n        PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n        FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n        HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n        RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n        ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n        GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n        SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n    return {\n        NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n        NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n        NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n        ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n        OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n        PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n        IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n        IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n    };\n}\nvar URI_PROTOCOL = buildExps(false);\n\nvar IRI_PROTOCOL = buildExps(true);\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/** Highest positive signed 32-bit float value */\n\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128; // 0x80\nvar delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nvar regexPunycode = /^xn--/;\nvar regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nvar regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nvar errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nvar baseMinusTMin = base - tMin;\nvar floor = Math.floor;\nvar stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error$1(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tvar result = [];\n\tvar length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tvar parts = string.split('@');\n\tvar result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tvar labels = string.split('.');\n\tvar encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tvar output = [];\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t// Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nvar ucs2encode = function ucs2encode(array) {\n\treturn String.fromCodePoint.apply(String, toConsumableArray(array));\n};\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nvar basicToDigit = function basicToDigit(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nvar digitToBasic = function digitToBasic(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nvar adapt = function adapt(delta, numPoints, firstTime) {\n\tvar k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nvar decode = function decode(input) {\n\t// Don't use UCS-2.\n\tvar output = [];\n\tvar inputLength = input.length;\n\tvar i = 0;\n\tvar n = initialN;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tvar basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (var j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror$1('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tvar oldi = i;\n\t\tfor (var w = 1, k = base;; /* no condition */k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror$1('invalid-input');\n\t\t\t}\n\n\t\t\tvar digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\t\t}\n\n\t\tvar out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\t}\n\n\treturn String.fromCodePoint.apply(String, output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nvar encode = function encode(input) {\n\tvar output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tvar inputLength = input.length;\n\n\t// Initialize the state.\n\tvar n = initialN;\n\tvar delta = 0;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points.\n\tvar _iteratorNormalCompletion = true;\n\tvar _didIteratorError = false;\n\tvar _iteratorError = undefined;\n\n\ttry {\n\t\tfor (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\tvar _currentValue2 = _step.value;\n\n\t\t\tif (_currentValue2 < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(_currentValue2));\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError = true;\n\t\t_iteratorError = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t_iterator.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError) {\n\t\t\t\tthrow _iteratorError;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar basicLength = output.length;\n\tvar handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tvar m = maxInt;\n\t\tvar _iteratorNormalCompletion2 = true;\n\t\tvar _didIteratorError2 = false;\n\t\tvar _iteratorError2 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\tvar currentValue = _step2.value;\n\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow.\n\t\t} catch (err) {\n\t\t\t_didIteratorError2 = true;\n\t\t\t_iteratorError2 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t_iterator2.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tvar _iteratorNormalCompletion3 = true;\n\t\tvar _didIteratorError3 = false;\n\t\tvar _iteratorError3 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\tvar _currentValue = _step3.value;\n\n\t\t\t\tif (_currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror$1('overflow');\n\t\t\t\t}\n\t\t\t\tif (_currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\t\tvar q = delta;\n\t\t\t\t\tfor (var k = base;; /* no condition */k += base) {\n\t\t\t\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar qMinusT = q - t;\n\t\t\t\t\t\tvar baseMinusT = base - t;\n\t\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError3 = true;\n\t\t\t_iteratorError3 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t_iterator3.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nvar toUnicode = function toUnicode(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nvar toASCII = function toASCII(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nvar punycode = {\n\t/**\n  * A string representing the current Punycode.js version number.\n  * @memberOf punycode\n  * @type String\n  */\n\t'version': '2.1.0',\n\t/**\n  * An object of methods to convert from JavaScript's internal character\n  * representation (UCS-2) to Unicode code points, and back.\n  * @see <https://mathiasbynens.be/notes/javascript-encoding>\n  * @memberOf punycode\n  * @type Object\n  */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\n/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\nvar SCHEMES = {};\nfunction pctEncChar(chr) {\n    var c = chr.charCodeAt(0);\n    var e = void 0;\n    if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n    return e;\n}\nfunction pctDecChars(str) {\n    var newStr = \"\";\n    var i = 0;\n    var il = str.length;\n    while (i < il) {\n        var c = parseInt(str.substr(i + 1, 2), 16);\n        if (c < 128) {\n            newStr += String.fromCharCode(c);\n            i += 3;\n        } else if (c >= 194 && c < 224) {\n            if (il - i >= 6) {\n                var c2 = parseInt(str.substr(i + 4, 2), 16);\n                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n            } else {\n                newStr += str.substr(i, 6);\n            }\n            i += 6;\n        } else if (c >= 224) {\n            if (il - i >= 9) {\n                var _c = parseInt(str.substr(i + 4, 2), 16);\n                var c3 = parseInt(str.substr(i + 7, 2), 16);\n                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n            } else {\n                newStr += str.substr(i, 9);\n            }\n            i += 9;\n        } else {\n            newStr += str.substr(i, 3);\n            i += 3;\n        }\n    }\n    return newStr;\n}\nfunction _normalizeComponentEncoding(components, protocol) {\n    function decodeUnreserved(str) {\n        var decStr = pctDecChars(str);\n        return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n    }\n    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    return components;\n}\n\nfunction _stripLeadingZeros(str) {\n    return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\nfunction _normalizeIPv4(host, protocol) {\n    var matches = host.match(protocol.IPV4ADDRESS) || [];\n\n    var _matches = slicedToArray(matches, 2),\n        address = _matches[1];\n\n    if (address) {\n        return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n    } else {\n        return host;\n    }\n}\nfunction _normalizeIPv6(host, protocol) {\n    var matches = host.match(protocol.IPV6ADDRESS) || [];\n\n    var _matches2 = slicedToArray(matches, 3),\n        address = _matches2[1],\n        zone = _matches2[2];\n\n    if (address) {\n        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),\n            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),\n            last = _address$toLowerCase$2[0],\n            first = _address$toLowerCase$2[1];\n\n        var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n        var lastFields = last.split(\":\").map(_stripLeadingZeros);\n        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n        var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n        var lastFieldsStart = lastFields.length - fieldCount;\n        var fields = Array(fieldCount);\n        for (var x = 0; x < fieldCount; ++x) {\n            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n        }\n        if (isLastFieldIPv4Address) {\n            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n        }\n        var allZeroFields = fields.reduce(function (acc, field, index) {\n            if (!field || field === \"0\") {\n                var lastLongest = acc[acc.length - 1];\n                if (lastLongest && lastLongest.index + lastLongest.length === index) {\n                    lastLongest.length++;\n                } else {\n                    acc.push({ index: index, length: 1 });\n                }\n            }\n            return acc;\n        }, []);\n        var longestZeroFields = allZeroFields.sort(function (a, b) {\n            return b.length - a.length;\n        })[0];\n        var newHost = void 0;\n        if (longestZeroFields && longestZeroFields.length > 1) {\n            var newFirst = fields.slice(0, longestZeroFields.index);\n            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n            newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n        } else {\n            newHost = fields.join(\":\");\n        }\n        if (zone) {\n            newHost += \"%\" + zone;\n        }\n        return newHost;\n    } else {\n        return host;\n    }\n}\nvar URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nvar NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\nfunction parse(uriString) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var components = {};\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n    var matches = uriString.match(URI_PARSE);\n    if (matches) {\n        if (NO_MATCH_IS_UNDEFINED) {\n            //store each component\n            components.scheme = matches[1];\n            components.userinfo = matches[3];\n            components.host = matches[4];\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = matches[7];\n            components.fragment = matches[8];\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = matches[5];\n            }\n        } else {\n            //IE FIX for improper RegExp matching\n            //store each component\n            components.scheme = matches[1] || undefined;\n            components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n            components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n            components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n            }\n        }\n        if (components.host) {\n            //normalize IP hosts\n            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n        }\n        //determine reference type\n        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n            components.reference = \"same-document\";\n        } else if (components.scheme === undefined) {\n            components.reference = \"relative\";\n        } else if (components.fragment === undefined) {\n            components.reference = \"absolute\";\n        } else {\n            components.reference = \"uri\";\n        }\n        //check for reference errors\n        if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n            components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n        }\n        //find scheme handler\n        var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n        //check if scheme can't handle IRIs\n        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n            //if host component is a domain name\n            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            }\n            //convert IRI -> URI\n            _normalizeComponentEncoding(components, URI_PROTOCOL);\n        } else {\n            //normalize encodings\n            _normalizeComponentEncoding(components, protocol);\n        }\n        //perform scheme specific parsing\n        if (schemeHandler && schemeHandler.parse) {\n            schemeHandler.parse(components, options);\n        }\n    } else {\n        components.error = components.error || \"URI can not be parsed.\";\n    }\n    return components;\n}\n\nfunction _recomposeAuthority(components, options) {\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    if (components.userinfo !== undefined) {\n        uriTokens.push(components.userinfo);\n        uriTokens.push(\"@\");\n    }\n    if (components.host !== undefined) {\n        //normalize IP hosts, add brackets and escape zone separator for IPv6\n        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {\n            return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n        }));\n    }\n    if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n        uriTokens.push(\":\");\n        uriTokens.push(String(components.port));\n    }\n    return uriTokens.length ? uriTokens.join(\"\") : undefined;\n}\n\nvar RDS1 = /^\\.\\.?\\//;\nvar RDS2 = /^\\/\\.(\\/|$)/;\nvar RDS3 = /^\\/\\.\\.(\\/|$)/;\nvar RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\nfunction removeDotSegments(input) {\n    var output = [];\n    while (input.length) {\n        if (input.match(RDS1)) {\n            input = input.replace(RDS1, \"\");\n        } else if (input.match(RDS2)) {\n            input = input.replace(RDS2, \"/\");\n        } else if (input.match(RDS3)) {\n            input = input.replace(RDS3, \"/\");\n            output.pop();\n        } else if (input === \".\" || input === \"..\") {\n            input = \"\";\n        } else {\n            var im = input.match(RDS5);\n            if (im) {\n                var s = im[0];\n                input = input.slice(s.length);\n                output.push(s);\n            } else {\n                throw new Error(\"Unexpected dot segment condition\");\n            }\n        }\n    }\n    return output.join(\"\");\n}\n\nfunction serialize(components) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    //find scheme handler\n    var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n    //perform scheme specific serialization\n    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n    if (components.host) {\n        //if host component is an IPv6 address\n        if (protocol.IPV6ADDRESS.test(components.host)) {}\n        //TODO: normalize IPv6 address as per RFC 5952\n\n        //if host component is a domain name\n        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n                //convert IDN via punycode\n                try {\n                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n            }\n    }\n    //normalize encoding\n    _normalizeComponentEncoding(components, protocol);\n    if (options.reference !== \"suffix\" && components.scheme) {\n        uriTokens.push(components.scheme);\n        uriTokens.push(\":\");\n    }\n    var authority = _recomposeAuthority(components, options);\n    if (authority !== undefined) {\n        if (options.reference !== \"suffix\") {\n            uriTokens.push(\"//\");\n        }\n        uriTokens.push(authority);\n        if (components.path && components.path.charAt(0) !== \"/\") {\n            uriTokens.push(\"/\");\n        }\n    }\n    if (components.path !== undefined) {\n        var s = components.path;\n        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n            s = removeDotSegments(s);\n        }\n        if (authority === undefined) {\n            s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n        }\n        uriTokens.push(s);\n    }\n    if (components.query !== undefined) {\n        uriTokens.push(\"?\");\n        uriTokens.push(components.query);\n    }\n    if (components.fragment !== undefined) {\n        uriTokens.push(\"#\");\n        uriTokens.push(components.fragment);\n    }\n    return uriTokens.join(\"\"); //merge tokens into a string\n}\n\nfunction resolveComponents(base, relative) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var skipNormalization = arguments[3];\n\n    var target = {};\n    if (!skipNormalization) {\n        base = parse(serialize(base, options), options); //normalize base components\n        relative = parse(serialize(relative, options), options); //normalize relative components\n    }\n    options = options || {};\n    if (!options.tolerant && relative.scheme) {\n        target.scheme = relative.scheme;\n        //target.authority = relative.authority;\n        target.userinfo = relative.userinfo;\n        target.host = relative.host;\n        target.port = relative.port;\n        target.path = removeDotSegments(relative.path || \"\");\n        target.query = relative.query;\n    } else {\n        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n            //target.authority = relative.authority;\n            target.userinfo = relative.userinfo;\n            target.host = relative.host;\n            target.port = relative.port;\n            target.path = removeDotSegments(relative.path || \"\");\n            target.query = relative.query;\n        } else {\n            if (!relative.path) {\n                target.path = base.path;\n                if (relative.query !== undefined) {\n                    target.query = relative.query;\n                } else {\n                    target.query = base.query;\n                }\n            } else {\n                if (relative.path.charAt(0) === \"/\") {\n                    target.path = removeDotSegments(relative.path);\n                } else {\n                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n                        target.path = \"/\" + relative.path;\n                    } else if (!base.path) {\n                        target.path = relative.path;\n                    } else {\n                        target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n                    }\n                    target.path = removeDotSegments(target.path);\n                }\n                target.query = relative.query;\n            }\n            //target.authority = base.authority;\n            target.userinfo = base.userinfo;\n            target.host = base.host;\n            target.port = base.port;\n        }\n        target.scheme = base.scheme;\n    }\n    target.fragment = relative.fragment;\n    return target;\n}\n\nfunction resolve(baseURI, relativeURI, options) {\n    var schemelessOptions = assign({ scheme: 'null' }, options);\n    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n}\n\nfunction normalize(uri, options) {\n    if (typeof uri === \"string\") {\n        uri = serialize(parse(uri, options), options);\n    } else if (typeOf(uri) === \"object\") {\n        uri = parse(serialize(uri, options), options);\n    }\n    return uri;\n}\n\nfunction equal(uriA, uriB, options) {\n    if (typeof uriA === \"string\") {\n        uriA = serialize(parse(uriA, options), options);\n    } else if (typeOf(uriA) === \"object\") {\n        uriA = serialize(uriA, options);\n    }\n    if (typeof uriB === \"string\") {\n        uriB = serialize(parse(uriB, options), options);\n    } else if (typeOf(uriB) === \"object\") {\n        uriB = serialize(uriB, options);\n    }\n    return uriA === uriB;\n}\n\nfunction escapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n}\n\nfunction unescapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n}\n\nvar handler = {\n    scheme: \"http\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        //report missing host\n        if (!components.host) {\n            components.error = components.error || \"HTTP URIs must have a host.\";\n        }\n        return components;\n    },\n    serialize: function serialize(components, options) {\n        var secure = String(components.scheme).toLowerCase() === \"https\";\n        //normalize the default port\n        if (components.port === (secure ? 443 : 80) || components.port === \"\") {\n            components.port = undefined;\n        }\n        //normalize the empty path\n        if (!components.path) {\n            components.path = \"/\";\n        }\n        //NOTE: We do not parse query strings for HTTP URIs\n        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n        //and not the HTTP spec.\n        return components;\n    }\n};\n\nvar handler$1 = {\n    scheme: \"https\",\n    domainHost: handler.domainHost,\n    parse: handler.parse,\n    serialize: handler.serialize\n};\n\nfunction isSecure(wsComponents) {\n    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n}\n//RFC 6455\nvar handler$2 = {\n    scheme: \"ws\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        var wsComponents = components;\n        //indicate if the secure flag is set\n        wsComponents.secure = isSecure(wsComponents);\n        //construct resouce name\n        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n        wsComponents.path = undefined;\n        wsComponents.query = undefined;\n        return wsComponents;\n    },\n    serialize: function serialize(wsComponents, options) {\n        //normalize the default port\n        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n            wsComponents.port = undefined;\n        }\n        //ensure scheme matches secure flag\n        if (typeof wsComponents.secure === 'boolean') {\n            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';\n            wsComponents.secure = undefined;\n        }\n        //reconstruct path from resource name\n        if (wsComponents.resourceName) {\n            var _wsComponents$resourc = wsComponents.resourceName.split('?'),\n                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),\n                path = _wsComponents$resourc2[0],\n                query = _wsComponents$resourc2[1];\n\n            wsComponents.path = path && path !== '/' ? path : undefined;\n            wsComponents.query = query;\n            wsComponents.resourceName = undefined;\n        }\n        //forbid fragment component\n        wsComponents.fragment = undefined;\n        return wsComponents;\n    }\n};\n\nvar handler$3 = {\n    scheme: \"wss\",\n    domainHost: handler$2.domainHost,\n    parse: handler$2.parse,\n    serialize: handler$2.serialize\n};\n\nvar O = {};\nvar isIRI = true;\n//RFC 3986\nvar UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nvar HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\nvar PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nvar ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nvar QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nvar VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nvar SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nvar UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nvar PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nvar NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nvar NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nvar NOT_HFVALUE = NOT_HFNAME;\nfunction decodeUnreserved(str) {\n    var decStr = pctDecChars(str);\n    return !decStr.match(UNRESERVED) ? str : decStr;\n}\nvar handler$4 = {\n    scheme: \"mailto\",\n    parse: function parse$$1(components, options) {\n        var mailtoComponents = components;\n        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n        mailtoComponents.path = undefined;\n        if (mailtoComponents.query) {\n            var unknownHeaders = false;\n            var headers = {};\n            var hfields = mailtoComponents.query.split(\"&\");\n            for (var x = 0, xl = hfields.length; x < xl; ++x) {\n                var hfield = hfields[x].split(\"=\");\n                switch (hfield[0]) {\n                    case \"to\":\n                        var toAddrs = hfield[1].split(\",\");\n                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {\n                            to.push(toAddrs[_x]);\n                        }\n                        break;\n                    case \"subject\":\n                        mailtoComponents.subject = unescapeComponent(hfield[1], options);\n                        break;\n                    case \"body\":\n                        mailtoComponents.body = unescapeComponent(hfield[1], options);\n                        break;\n                    default:\n                        unknownHeaders = true;\n                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n                        break;\n                }\n            }\n            if (unknownHeaders) mailtoComponents.headers = headers;\n        }\n        mailtoComponents.query = undefined;\n        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {\n            var addr = to[_x2].split(\"@\");\n            addr[0] = unescapeComponent(addr[0]);\n            if (!options.unicodeSupport) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n                } catch (e) {\n                    mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            } else {\n                addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n            }\n            to[_x2] = addr.join(\"@\");\n        }\n        return mailtoComponents;\n    },\n    serialize: function serialize$$1(mailtoComponents, options) {\n        var components = mailtoComponents;\n        var to = toArray(mailtoComponents.to);\n        if (to) {\n            for (var x = 0, xl = to.length; x < xl; ++x) {\n                var toAddr = String(to[x]);\n                var atIdx = toAddr.lastIndexOf(\"@\");\n                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n                var domain = toAddr.slice(atIdx + 1);\n                //convert IDN via punycode\n                try {\n                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n                } catch (e) {\n                    components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n                to[x] = localPart + \"@\" + domain;\n            }\n            components.path = to.join(\",\");\n        }\n        var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n        if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n        if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n        var fields = [];\n        for (var name in headers) {\n            if (headers[name] !== O[name]) {\n                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n            }\n        }\n        if (fields.length) {\n            components.query = fields.join(\"&\");\n        }\n        return components;\n    }\n};\n\nvar URN_PARSE = /^([^\\:]+)\\:(.*)/;\n//RFC 2141\nvar handler$5 = {\n    scheme: \"urn\",\n    parse: function parse$$1(components, options) {\n        var matches = components.path && components.path.match(URN_PARSE);\n        var urnComponents = components;\n        if (matches) {\n            var scheme = options.scheme || urnComponents.scheme || \"urn\";\n            var nid = matches[1].toLowerCase();\n            var nss = matches[2];\n            var urnScheme = scheme + \":\" + (options.nid || nid);\n            var schemeHandler = SCHEMES[urnScheme];\n            urnComponents.nid = nid;\n            urnComponents.nss = nss;\n            urnComponents.path = undefined;\n            if (schemeHandler) {\n                urnComponents = schemeHandler.parse(urnComponents, options);\n            }\n        } else {\n            urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n        }\n        return urnComponents;\n    },\n    serialize: function serialize$$1(urnComponents, options) {\n        var scheme = options.scheme || urnComponents.scheme || \"urn\";\n        var nid = urnComponents.nid;\n        var urnScheme = scheme + \":\" + (options.nid || nid);\n        var schemeHandler = SCHEMES[urnScheme];\n        if (schemeHandler) {\n            urnComponents = schemeHandler.serialize(urnComponents, options);\n        }\n        var uriComponents = urnComponents;\n        var nss = urnComponents.nss;\n        uriComponents.path = (nid || options.nid) + \":\" + nss;\n        return uriComponents;\n    }\n};\n\nvar UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n//RFC 4122\nvar handler$6 = {\n    scheme: \"urn:uuid\",\n    parse: function parse(urnComponents, options) {\n        var uuidComponents = urnComponents;\n        uuidComponents.uuid = uuidComponents.nss;\n        uuidComponents.nss = undefined;\n        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n            uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n        }\n        return uuidComponents;\n    },\n    serialize: function serialize(uuidComponents, options) {\n        var urnComponents = uuidComponents;\n        //normalize UUID\n        urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n        return urnComponents;\n    }\n};\n\nSCHEMES[handler.scheme] = handler;\nSCHEMES[handler$1.scheme] = handler$1;\nSCHEMES[handler$2.scheme] = handler$2;\nSCHEMES[handler$3.scheme] = handler$3;\nSCHEMES[handler$4.scheme] = handler$4;\nSCHEMES[handler$5.scheme] = handler$5;\nSCHEMES[handler$6.scheme] = handler$6;\n\nexports.SCHEMES = SCHEMES;\nexports.pctEncChar = pctEncChar;\nexports.pctDecChars = pctDecChars;\nexports.parse = parse;\nexports.removeDotSegments = removeDotSegments;\nexports.serialize = serialize;\nexports.resolveComponents = resolveComponents;\nexports.resolve = resolve;\nexports.normalize = normalize;\nexports.equal = equal;\nexports.escapeComponent = escapeComponent;\nexports.unescapeComponent = unescapeComponent;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"],"mappings":"AAAA;AACC,WAAUA,MAAV,EAAkBC,OAAlB,EAA2B;EAC3B,OAAOC,OAAP,KAAmB,QAAnB,IAA+B,OAAOC,MAAP,KAAkB,WAAjD,GAA+DF,OAAO,CAACC,OAAD,CAAtE,GACA,OAAOE,MAAP,KAAkB,UAAlB,IAAgCA,MAAM,CAACC,GAAvC,GAA6CD,MAAM,CAAC,CAAC,SAAD,CAAD,EAAcH,OAAd,CAAnD,GACCA,OAAO,CAAED,MAAM,CAACM,GAAP,GAAaN,MAAM,CAACM,GAAP,IAAc,EAA7B,CAFR;AAGA,CAJA,EAIC,IAJD,EAIQ,UAAUJ,OAAV,EAAmB;EAAE;;EAE9B,SAASK,KAAT,GAAiB;IACb,KAAK,IAAIC,IAAI,GAAGC,SAAS,CAACC,MAArB,EAA6BC,IAAI,GAAGC,KAAK,CAACJ,IAAD,CAAzC,EAAiDK,IAAI,GAAG,CAA7D,EAAgEA,IAAI,GAAGL,IAAvE,EAA6EK,IAAI,EAAjF,EAAqF;MACjFF,IAAI,CAACE,IAAD,CAAJ,GAAaJ,SAAS,CAACI,IAAD,CAAtB;IACH;;IAED,IAAIF,IAAI,CAACD,MAAL,GAAc,CAAlB,EAAqB;MACjBC,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAAJ,CAAQG,KAAR,CAAc,CAAd,EAAiB,CAAC,CAAlB,CAAV;MACA,IAAIC,EAAE,GAAGJ,IAAI,CAACD,MAAL,GAAc,CAAvB;;MACA,KAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,EAApB,EAAwB,EAAEC,CAA1B,EAA6B;QACzBL,IAAI,CAACK,CAAD,CAAJ,GAAUL,IAAI,CAACK,CAAD,CAAJ,CAAQF,KAAR,CAAc,CAAd,EAAiB,CAAC,CAAlB,CAAV;MACH;;MACDH,IAAI,CAACI,EAAD,CAAJ,GAAWJ,IAAI,CAACI,EAAD,CAAJ,CAASD,KAAT,CAAe,CAAf,CAAX;MACA,OAAOH,IAAI,CAACM,IAAL,CAAU,EAAV,CAAP;IACH,CARD,MAQO;MACH,OAAON,IAAI,CAAC,CAAD,CAAX;IACH;EACJ;;EACD,SAASO,MAAT,CAAgBC,GAAhB,EAAqB;IACjB,OAAO,QAAQA,GAAR,GAAc,GAArB;EACH;;EACD,SAASC,MAAT,CAAgBC,CAAhB,EAAmB;IACf,OAAOA,CAAC,KAAKC,SAAN,GAAkB,WAAlB,GAAgCD,CAAC,KAAK,IAAN,GAAa,MAAb,GAAsBE,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BL,CAA/B,EAAkCM,KAAlC,CAAwC,GAAxC,EAA6CC,GAA7C,GAAmDD,KAAnD,CAAyD,GAAzD,EAA8DE,KAA9D,GAAsEC,WAAtE,EAA7D;EACH;;EACD,SAASC,WAAT,CAAqBZ,GAArB,EAA0B;IACtB,OAAOA,GAAG,CAACY,WAAJ,EAAP;EACH;;EACD,SAASC,OAAT,CAAiBC,GAAjB,EAAsB;IAClB,OAAOA,GAAG,KAAKX,SAAR,IAAqBW,GAAG,KAAK,IAA7B,GAAoCA,GAAG,YAAYrB,KAAf,GAAuBqB,GAAvB,GAA6B,OAAOA,GAAG,CAACvB,MAAX,KAAsB,QAAtB,IAAkCuB,GAAG,CAACN,KAAtC,IAA+CM,GAAG,CAACC,WAAnD,IAAkED,GAAG,CAACP,IAAtE,GAA6E,CAACO,GAAD,CAA7E,GAAqFrB,KAAK,CAACY,SAAN,CAAgBV,KAAhB,CAAsBY,IAAtB,CAA2BO,GAA3B,CAAtJ,GAAwL,EAA/L;EACH;;EACD,SAASE,MAAT,CAAgBC,MAAhB,EAAwBC,MAAxB,EAAgC;IAC5B,IAAIJ,GAAG,GAAGG,MAAV;;IACA,IAAIC,MAAJ,EAAY;MACR,KAAK,IAAIC,GAAT,IAAgBD,MAAhB,EAAwB;QACpBJ,GAAG,CAACK,GAAD,CAAH,GAAWD,MAAM,CAACC,GAAD,CAAjB;MACH;IACJ;;IACD,OAAOL,GAAP;EACH;;EAED,SAASM,SAAT,CAAmBC,KAAnB,EAA0B;IACtB,IAAIC,OAAO,GAAG,UAAd;IAAA,IACIC,GAAG,GAAG,SADV;IAAA,IAEIC,OAAO,GAAG,OAFd;IAAA,IAGIC,QAAQ,GAAG,SAHf;IAAA,IAIIC,QAAQ,GAAGtC,KAAK,CAACoC,OAAD,EAAU,UAAV,CAJpB;IAAA,IAKI;IACJG,IAAI,GAAG,SANP;IAAA,IAOIC,IAAI,GAAG,SAPX;IAAA,IAQIC,YAAY,GAAG9B,MAAM,CAACA,MAAM,CAAC,YAAY2B,QAAZ,GAAuB,GAAvB,GAA6BA,QAA7B,GAAwCA,QAAxC,GAAmD,GAAnD,GAAyDA,QAAzD,GAAoEA,QAArE,CAAN,GAAuF,GAAvF,GAA6F3B,MAAM,CAAC,gBAAgB2B,QAAhB,GAA2B,GAA3B,GAAiCA,QAAjC,GAA4CA,QAA7C,CAAnG,GAA4J,GAA5J,GAAkK3B,MAAM,CAAC,MAAM2B,QAAN,GAAiBA,QAAlB,CAAzK,CARzB;IAAA,IASI;IACJI,YAAY,GAAG,yBAVf;IAAA,IAWIC,YAAY,GAAG,qCAXnB;IAAA,IAYIC,UAAU,GAAG5C,KAAK,CAAC0C,YAAD,EAAeC,YAAf,CAZtB;IAAA,IAaIE,SAAS,GAAGZ,KAAK,GAAG,6EAAH,GAAmF,IAbxG;IAAA,IAcI;IACJa,UAAU,GAAGb,KAAK,GAAG,mBAAH,GAAyB,IAf3C;IAAA,IAgBI;IACJc,YAAY,GAAG/C,KAAK,CAACkC,OAAD,EAAUE,OAAV,EAAmB,gBAAnB,EAAqCS,SAArC,CAjBpB;IAAA,IAkBIG,OAAO,GAAGrC,MAAM,CAACuB,OAAO,GAAGlC,KAAK,CAACkC,OAAD,EAAUE,OAAV,EAAmB,aAAnB,CAAf,GAAmD,GAApD,CAlBpB;IAAA,IAmBIa,SAAS,GAAGtC,MAAM,CAACA,MAAM,CAAC8B,YAAY,GAAG,GAAf,GAAqBzC,KAAK,CAAC+C,YAAD,EAAeJ,YAAf,EAA6B,OAA7B,CAA3B,CAAN,GAA0E,GAA3E,CAnBtB;IAAA,IAoBIO,UAAU,GAAGvC,MAAM,CAACA,MAAM,CAAC,SAAD,CAAN,GAAoB,GAApB,GAA0BA,MAAM,CAAC,WAAWyB,OAAZ,CAAhC,GAAuD,GAAvD,GAA6DzB,MAAM,CAAC,MAAMyB,OAAN,GAAgBA,OAAjB,CAAnE,GAA+F,GAA/F,GAAqGzB,MAAM,CAAC,UAAUyB,OAAX,CAA3G,GAAiI,GAAjI,GAAuIA,OAAxI,CApBvB;IAAA,IAqBIe,kBAAkB,GAAGxC,MAAM,CAACA,MAAM,CAAC,SAAD,CAAN,GAAoB,GAApB,GAA0BA,MAAM,CAAC,WAAWyB,OAAZ,CAAhC,GAAuD,GAAvD,GAA6DzB,MAAM,CAAC,MAAMyB,OAAN,GAAgBA,OAAjB,CAAnE,GAA+F,GAA/F,GAAqGzB,MAAM,CAAC,YAAYyB,OAAb,CAA3G,GAAmI,OAAnI,GAA6IA,OAA9I,CArB/B;IAAA,IAsBI;IACJgB,YAAY,GAAGzC,MAAM,CAACwC,kBAAkB,GAAG,KAArB,GAA6BA,kBAA7B,GAAkD,KAAlD,GAA0DA,kBAA1D,GAA+E,KAA/E,GAAuFA,kBAAxF,CAvBrB;IAAA,IAwBIE,IAAI,GAAG1C,MAAM,CAAC2B,QAAQ,GAAG,OAAZ,CAxBjB;IAAA,IAyBIgB,KAAK,GAAG3C,MAAM,CAACA,MAAM,CAAC0C,IAAI,GAAG,KAAP,GAAeA,IAAhB,CAAN,GAA8B,GAA9B,GAAoCD,YAArC,CAzBlB;IAAA,IA0BIG,aAAa,GAAG5C,MAAM,CAACA,MAAM,CAAC0C,IAAI,GAAG,KAAR,CAAN,GAAuB,KAAvB,GAA+BC,KAAhC,CA1B1B;IAAA,IA2BI;IACJE,aAAa,GAAG7C,MAAM,CAAC,WAAWA,MAAM,CAAC0C,IAAI,GAAG,KAAR,CAAjB,GAAkC,KAAlC,GAA0CC,KAA3C,CA5BtB;IAAA,IA6BI;IACJG,aAAa,GAAG9C,MAAM,CAACA,MAAM,CAAC0C,IAAD,CAAN,GAAe,SAAf,GAA2B1C,MAAM,CAAC0C,IAAI,GAAG,KAAR,CAAjC,GAAkD,KAAlD,GAA0DC,KAA3D,CA9BtB;IAAA,IA+BI;IACJI,aAAa,GAAG/C,MAAM,CAACA,MAAM,CAACA,MAAM,CAAC0C,IAAI,GAAG,KAAR,CAAN,GAAuB,OAAvB,GAAiCA,IAAlC,CAAN,GAAgD,SAAhD,GAA4D1C,MAAM,CAAC0C,IAAI,GAAG,KAAR,CAAlE,GAAmF,KAAnF,GAA2FC,KAA5F,CAhCtB;IAAA,IAiCI;IACJK,aAAa,GAAGhD,MAAM,CAACA,MAAM,CAACA,MAAM,CAAC0C,IAAI,GAAG,KAAR,CAAN,GAAuB,OAAvB,GAAiCA,IAAlC,CAAN,GAAgD,SAAhD,GAA4D1C,MAAM,CAAC0C,IAAI,GAAG,KAAR,CAAlE,GAAmF,KAAnF,GAA2FC,KAA5F,CAlCtB;IAAA,IAmCI;IACJM,aAAa,GAAGjD,MAAM,CAACA,MAAM,CAACA,MAAM,CAAC0C,IAAI,GAAG,KAAR,CAAN,GAAuB,OAAvB,GAAiCA,IAAlC,CAAN,GAAgD,SAAhD,GAA4DA,IAA5D,GAAmE,KAAnE,GAA2EC,KAA5E,CApCtB;IAAA,IAqCI;IACJO,aAAa,GAAGlD,MAAM,CAACA,MAAM,CAACA,MAAM,CAAC0C,IAAI,GAAG,KAAR,CAAN,GAAuB,OAAvB,GAAiCA,IAAlC,CAAN,GAAgD,SAAhD,GAA4DC,KAA7D,CAtCtB;IAAA,IAuCI;IACJQ,aAAa,GAAGnD,MAAM,CAACA,MAAM,CAACA,MAAM,CAAC0C,IAAI,GAAG,KAAR,CAAN,GAAuB,OAAvB,GAAiCA,IAAlC,CAAN,GAAgD,SAAhD,GAA4DA,IAA7D,CAxCtB;IAAA,IAyCI;IACJU,aAAa,GAAGpD,MAAM,CAACA,MAAM,CAACA,MAAM,CAAC0C,IAAI,GAAG,KAAR,CAAN,GAAuB,OAAvB,GAAiCA,IAAlC,CAAN,GAAgD,SAAjD,CA1CtB;IAAA,IA2CI;IACJW,YAAY,GAAGrD,MAAM,CAAC,CAAC4C,aAAD,EAAgBC,aAAhB,EAA+BC,aAA/B,EAA8CC,aAA9C,EAA6DC,aAA7D,EAA4EC,aAA5E,EAA2FC,aAA3F,EAA0GC,aAA1G,EAAyHC,aAAzH,EAAwIrD,IAAxI,CAA6I,GAA7I,CAAD,CA5CrB;IAAA,IA6CIuD,OAAO,GAAGtD,MAAM,CAACA,MAAM,CAACoC,YAAY,GAAG,GAAf,GAAqBN,YAAtB,CAAN,GAA4C,GAA7C,CA7CpB;IAAA,IA8CI;IACJyB,UAAU,GAAGvD,MAAM,CAACqD,YAAY,GAAG,OAAf,GAAyBC,OAA1B,CA/CnB;IAAA,IAgDI;IACJE,kBAAkB,GAAGxD,MAAM,CAACqD,YAAY,GAAGrD,MAAM,CAAC,iBAAiB2B,QAAjB,GAA4B,MAA7B,CAArB,GAA4D2B,OAA7D,CAjD3B;IAAA,IAkDI;IACJG,UAAU,GAAGzD,MAAM,CAAC,SAAS2B,QAAT,GAAoB,MAApB,GAA6BtC,KAAK,CAAC+C,YAAD,EAAeJ,YAAf,EAA6B,OAA7B,CAAlC,GAA0E,GAA3E,CAnDnB;IAAA,IAoDI0B,WAAW,GAAG1D,MAAM,CAAC,QAAQA,MAAM,CAACwD,kBAAkB,GAAG,GAArB,GAA2BH,YAA3B,GAA0C,GAA1C,GAAgDI,UAAjD,CAAd,GAA6E,KAA9E,CApDxB;IAAA,IAqDI;IACJE,SAAS,GAAG3D,MAAM,CAACA,MAAM,CAAC8B,YAAY,GAAG,GAAf,GAAqBzC,KAAK,CAAC+C,YAAD,EAAeJ,YAAf,CAA3B,CAAN,GAAiE,GAAlE,CAtDlB;IAAA,IAuDI4B,KAAK,GAAG5D,MAAM,CAAC0D,WAAW,GAAG,GAAd,GAAoBjB,YAApB,GAAmC,KAAnC,GAA2CkB,SAA3C,GAAuD,GAAvD,GAA6D,GAA7D,GAAmEA,SAApE,CAvDlB;IAAA,IAwDIE,KAAK,GAAG7D,MAAM,CAACyB,OAAO,GAAG,GAAX,CAxDlB;IAAA,IAyDIqC,UAAU,GAAG9D,MAAM,CAACA,MAAM,CAACsC,SAAS,GAAG,GAAb,CAAN,GAA0B,GAA1B,GAAgCsB,KAAhC,GAAwC5D,MAAM,CAAC,QAAQ6D,KAAT,CAA9C,GAAgE,GAAjE,CAzDvB;IAAA,IA0DIE,MAAM,GAAG/D,MAAM,CAAC8B,YAAY,GAAG,GAAf,GAAqBzC,KAAK,CAAC+C,YAAD,EAAeJ,YAAf,EAA6B,UAA7B,CAA3B,CA1DnB;IAAA,IA2DIgC,QAAQ,GAAGhE,MAAM,CAAC+D,MAAM,GAAG,GAAV,CA3DrB;IAAA,IA4DIE,WAAW,GAAGjE,MAAM,CAAC+D,MAAM,GAAG,GAAV,CA5DxB;IAAA,IA6DIG,cAAc,GAAGlE,MAAM,CAACA,MAAM,CAAC8B,YAAY,GAAG,GAAf,GAAqBzC,KAAK,CAAC+C,YAAD,EAAeJ,YAAf,EAA6B,OAA7B,CAA3B,CAAN,GAA0E,GAA3E,CA7D3B;IAAA,IA8DImC,aAAa,GAAGnE,MAAM,CAACA,MAAM,CAAC,QAAQgE,QAAT,CAAN,GAA2B,GAA5B,CA9D1B;IAAA,IA+DII,cAAc,GAAGpE,MAAM,CAAC,QAAQA,MAAM,CAACiE,WAAW,GAAGE,aAAf,CAAd,GAA8C,GAA/C,CA/D3B;IAAA,IAgEI;IACJE,cAAc,GAAGrE,MAAM,CAACkE,cAAc,GAAGC,aAAlB,CAjEvB;IAAA,IAkEI;IACJG,cAAc,GAAGtE,MAAM,CAACiE,WAAW,GAAGE,aAAf,CAnEvB;IAAA,IAoEI;IACJI,WAAW,GAAG,QAAQR,MAAR,GAAiB,GArE/B;IAAA,IAsEIS,KAAK,GAAGxE,MAAM,CAACmE,aAAa,GAAG,GAAhB,GAAsBC,cAAtB,GAAuC,GAAvC,GAA6CC,cAA7C,GAA8D,GAA9D,GAAoEC,cAApE,GAAqF,GAArF,GAA2FC,WAA5F,CAtElB;IAAA,IAuEIE,MAAM,GAAGzE,MAAM,CAACA,MAAM,CAAC+D,MAAM,GAAG,GAAT,GAAe1E,KAAK,CAAC,UAAD,EAAa8C,UAAb,CAArB,CAAN,GAAuD,GAAxD,CAvEnB;IAAA,IAwEIuC,SAAS,GAAG1E,MAAM,CAACA,MAAM,CAAC+D,MAAM,GAAG,WAAV,CAAN,GAA+B,GAAhC,CAxEtB;IAAA,IAyEIY,UAAU,GAAG3E,MAAM,CAACA,MAAM,CAAC,WAAW8D,UAAX,GAAwBK,aAAzB,CAAN,GAAgD,GAAhD,GAAsDC,cAAtD,GAAuE,GAAvE,GAA6EE,cAA7E,GAA8F,GAA9F,GAAoGC,WAArG,CAzEvB;IAAA,IA0EIK,IAAI,GAAG5E,MAAM,CAACqC,OAAO,GAAG,KAAV,GAAkBsC,UAAlB,GAA+B3E,MAAM,CAAC,QAAQyE,MAAT,CAArC,GAAwD,GAAxD,GAA8DzE,MAAM,CAAC,QAAQ0E,SAAT,CAApE,GAA0F,GAA3F,CA1EjB;IAAA,IA2EIG,cAAc,GAAG7E,MAAM,CAACA,MAAM,CAAC,WAAW8D,UAAX,GAAwBK,aAAzB,CAAN,GAAgD,GAAhD,GAAsDC,cAAtD,GAAuE,GAAvE,GAA6EC,cAA7E,GAA8F,GAA9F,GAAoGE,WAArG,CA3E3B;IAAA,IA4EIO,SAAS,GAAG9E,MAAM,CAAC6E,cAAc,GAAG7E,MAAM,CAAC,QAAQyE,MAAT,CAAvB,GAA0C,GAA1C,GAAgDzE,MAAM,CAAC,QAAQ0E,SAAT,CAAtD,GAA4E,GAA7E,CA5EtB;IAAA,IA6EIK,cAAc,GAAG/E,MAAM,CAAC4E,IAAI,GAAG,GAAP,GAAaE,SAAd,CA7E3B;IAAA,IA8EIE,aAAa,GAAGhF,MAAM,CAACqC,OAAO,GAAG,KAAV,GAAkBsC,UAAlB,GAA+B3E,MAAM,CAAC,QAAQyE,MAAT,CAArC,GAAwD,GAAzD,CA9E1B;IAAA,IA+EIQ,YAAY,GAAG,OAAO5C,OAAP,GAAiB,MAAjB,GAA0BrC,MAAM,CAACA,MAAM,CAAC,YAAYA,MAAM,CAAC,MAAMsC,SAAN,GAAkB,IAAnB,CAAlB,GAA6C,IAA7C,GAAoDsB,KAApD,GAA4D,GAA5D,GAAkE5D,MAAM,CAAC,SAAS6D,KAAT,GAAiB,GAAlB,CAAxE,GAAiG,IAAlG,CAAN,GAAgH,IAAhH,GAAuHM,aAAvH,GAAuI,GAAvI,GAA6IC,cAA7I,GAA8J,GAA9J,GAAoKE,cAApK,GAAqL,GAArL,GAA2LC,WAA3L,GAAyM,GAA1M,CAAhC,GAAiPvE,MAAM,CAAC,SAASyE,MAAT,GAAkB,GAAnB,CAAvP,GAAiR,GAAjR,GAAuRzE,MAAM,CAAC,SAAS0E,SAAT,GAAqB,GAAtB,CAA7R,GAA0T,IA/E7U;IAAA,IAgFIQ,aAAa,GAAG,WAAWlF,MAAM,CAACA,MAAM,CAAC,YAAYA,MAAM,CAAC,MAAMsC,SAAN,GAAkB,IAAnB,CAAlB,GAA6C,IAA7C,GAAoDsB,KAApD,GAA4D,GAA5D,GAAkE5D,MAAM,CAAC,SAAS6D,KAAT,GAAiB,GAAlB,CAAxE,GAAiG,IAAlG,CAAN,GAAgH,IAAhH,GAAuHM,aAAvH,GAAuI,GAAvI,GAA6IC,cAA7I,GAA8J,GAA9J,GAAoKC,cAApK,GAAqL,GAArL,GAA2LE,WAA3L,GAAyM,GAA1M,CAAjB,GAAkOvE,MAAM,CAAC,SAASyE,MAAT,GAAkB,GAAnB,CAAxO,GAAkQ,GAAlQ,GAAwQzE,MAAM,CAAC,SAAS0E,SAAT,GAAqB,GAAtB,CAA9Q,GAA2S,IAhF/T;IAAA,IAiFIS,aAAa,GAAG,OAAO9C,OAAP,GAAiB,MAAjB,GAA0BrC,MAAM,CAACA,MAAM,CAAC,YAAYA,MAAM,CAAC,MAAMsC,SAAN,GAAkB,IAAnB,CAAlB,GAA6C,IAA7C,GAAoDsB,KAApD,GAA4D,GAA5D,GAAkE5D,MAAM,CAAC,SAAS6D,KAAT,GAAiB,GAAlB,CAAxE,GAAiG,IAAlG,CAAN,GAAgH,IAAhH,GAAuHM,aAAvH,GAAuI,GAAvI,GAA6IC,cAA7I,GAA8J,GAA9J,GAAoKE,cAApK,GAAqL,GAArL,GAA2LC,WAA3L,GAAyM,GAA1M,CAAhC,GAAiPvE,MAAM,CAAC,SAASyE,MAAT,GAAkB,GAAnB,CAAvP,GAAiR,IAjFrS;IAAA,IAkFIW,YAAY,GAAG,MAAMpF,MAAM,CAAC,SAAS0E,SAAT,GAAqB,GAAtB,CAAZ,GAAyC,IAlF5D;IAAA,IAmFIW,cAAc,GAAG,MAAMrF,MAAM,CAAC,MAAMsC,SAAN,GAAkB,IAAnB,CAAZ,GAAuC,IAAvC,GAA8CsB,KAA9C,GAAsD,GAAtD,GAA4D5D,MAAM,CAAC,SAAS6D,KAAT,GAAiB,GAAlB,CAAlE,GAA2F,IAnFhH;IAoFA,OAAO;MACHyB,UAAU,EAAE,IAAIC,MAAJ,CAAWlG,KAAK,CAAC,KAAD,EAAQkC,OAAR,EAAiBE,OAAjB,EAA0B,aAA1B,CAAhB,EAA0D,GAA1D,CADT;MAEH+D,YAAY,EAAE,IAAID,MAAJ,CAAWlG,KAAK,CAAC,WAAD,EAAc+C,YAAd,EAA4BJ,YAA5B,CAAhB,EAA2D,GAA3D,CAFX;MAGHyD,QAAQ,EAAE,IAAIF,MAAJ,CAAWlG,KAAK,CAAC,iBAAD,EAAoB+C,YAApB,EAAkCJ,YAAlC,CAAhB,EAAiE,GAAjE,CAHP;MAIH0D,QAAQ,EAAE,IAAIH,MAAJ,CAAWlG,KAAK,CAAC,iBAAD,EAAoB+C,YAApB,EAAkCJ,YAAlC,CAAhB,EAAiE,GAAjE,CAJP;MAKH2D,iBAAiB,EAAE,IAAIJ,MAAJ,CAAWlG,KAAK,CAAC,cAAD,EAAiB+C,YAAjB,EAA+BJ,YAA/B,CAAhB,EAA8D,GAA9D,CALhB;MAMH4D,SAAS,EAAE,IAAIL,MAAJ,CAAWlG,KAAK,CAAC,QAAD,EAAW+C,YAAX,EAAyBJ,YAAzB,EAAuC,gBAAvC,EAAyDG,UAAzD,CAAhB,EAAsF,GAAtF,CANR;MAOH0D,YAAY,EAAE,IAAIN,MAAJ,CAAWlG,KAAK,CAAC,QAAD,EAAW+C,YAAX,EAAyBJ,YAAzB,EAAuC,gBAAvC,CAAhB,EAA0E,GAA1E,CAPX;MAQH8D,MAAM,EAAE,IAAIP,MAAJ,CAAWlG,KAAK,CAAC,KAAD,EAAQ+C,YAAR,EAAsBJ,YAAtB,CAAhB,EAAqD,GAArD,CARL;MASH+D,UAAU,EAAE,IAAIR,MAAJ,CAAWnD,YAAX,EAAyB,GAAzB,CATT;MAUH4D,WAAW,EAAE,IAAIT,MAAJ,CAAWlG,KAAK,CAAC,QAAD,EAAW+C,YAAX,EAAyBH,UAAzB,CAAhB,EAAsD,GAAtD,CAVV;MAWHgE,WAAW,EAAE,IAAIV,MAAJ,CAAWzD,YAAX,EAAyB,GAAzB,CAXV;MAYHoE,WAAW,EAAE,IAAIX,MAAJ,CAAW,OAAO9C,YAAP,GAAsB,IAAjC,CAZV;MAaH0D,WAAW,EAAE,IAAIZ,MAAJ,CAAW,WAAWlC,YAAX,GAA0B,GAA1B,GAAgCrD,MAAM,CAACA,MAAM,CAAC,iBAAiB2B,QAAjB,GAA4B,MAA7B,CAAN,GAA6C,GAA7C,GAAmD2B,OAAnD,GAA6D,GAA9D,CAAtC,GAA2G,QAAtH,CAbV,CAa0I;;IAb1I,CAAP;EAeH;;EACD,IAAI8C,YAAY,GAAG/E,SAAS,CAAC,KAAD,CAA5B;EAEA,IAAIgF,YAAY,GAAGhF,SAAS,CAAC,IAAD,CAA5B;;EAEA,IAAIiF,aAAa,GAAG,YAAY;IAC9B,SAASC,aAAT,CAAuBC,GAAvB,EAA4BC,CAA5B,EAA+B;MAC7B,IAAIC,IAAI,GAAG,EAAX;MACA,IAAIC,EAAE,GAAG,IAAT;MACA,IAAIC,EAAE,GAAG,KAAT;MACA,IAAIC,EAAE,GAAGzG,SAAT;;MAEA,IAAI;QACF,KAAK,IAAI0G,EAAE,GAAGN,GAAG,CAACO,MAAM,CAACC,QAAR,CAAH,EAAT,EAAiCC,EAAtC,EAA0C,EAAEN,EAAE,GAAG,CAACM,EAAE,GAAGH,EAAE,CAACI,IAAH,EAAN,EAAiBC,IAAxB,CAA1C,EAAyER,EAAE,GAAG,IAA9E,EAAoF;UAClFD,IAAI,CAACU,IAAL,CAAUH,EAAE,CAACI,KAAb;;UAEA,IAAIZ,CAAC,IAAIC,IAAI,CAAClH,MAAL,KAAgBiH,CAAzB,EAA4B;QAC7B;MACF,CAND,CAME,OAAOa,GAAP,EAAY;QACZV,EAAE,GAAG,IAAL;QACAC,EAAE,GAAGS,GAAL;MACD,CATD,SASU;QACR,IAAI;UACF,IAAI,CAACX,EAAD,IAAOG,EAAE,CAAC,QAAD,CAAb,EAAyBA,EAAE,CAAC,QAAD,CAAF;QAC1B,CAFD,SAEU;UACR,IAAIF,EAAJ,EAAQ,MAAMC,EAAN;QACT;MACF;;MAED,OAAOH,IAAP;IACD;;IAED,OAAO,UAAUF,GAAV,EAAeC,CAAf,EAAkB;MACvB,IAAI/G,KAAK,CAAC6H,OAAN,CAAcf,GAAd,CAAJ,EAAwB;QACtB,OAAOA,GAAP;MACD,CAFD,MAEO,IAAIO,MAAM,CAACC,QAAP,IAAmB3G,MAAM,CAACmG,GAAD,CAA7B,EAAoC;QACzC,OAAOD,aAAa,CAACC,GAAD,EAAMC,CAAN,CAApB;MACD,CAFM,MAEA;QACL,MAAM,IAAIe,SAAJ,CAAc,sDAAd,CAAN;MACD;IACF,CARD;EASD,CApCmB,EAApB;;EAkDA,IAAIC,iBAAiB,GAAG,UAAUjB,GAAV,EAAe;IACrC,IAAI9G,KAAK,CAAC6H,OAAN,CAAcf,GAAd,CAAJ,EAAwB;MACtB,KAAK,IAAIC,CAAC,GAAG,CAAR,EAAWiB,IAAI,GAAGhI,KAAK,CAAC8G,GAAG,CAAChH,MAAL,CAA5B,EAA0CiH,CAAC,GAAGD,GAAG,CAAChH,MAAlD,EAA0DiH,CAAC,EAA3D,EAA+DiB,IAAI,CAACjB,CAAD,CAAJ,GAAUD,GAAG,CAACC,CAAD,CAAb;;MAE/D,OAAOiB,IAAP;IACD,CAJD,MAIO;MACL,OAAOhI,KAAK,CAACiI,IAAN,CAAWnB,GAAX,CAAP;IACD;EACF,CARD;EAUA;;;EAEA,IAAIoB,MAAM,GAAG,UAAb,CAhN4B,CAgNH;;EAEzB;;EACA,IAAIC,IAAI,GAAG,EAAX;EACA,IAAIC,IAAI,GAAG,CAAX;EACA,IAAIC,IAAI,GAAG,EAAX;EACA,IAAIC,IAAI,GAAG,EAAX;EACA,IAAIC,IAAI,GAAG,GAAX;EACA,IAAIC,WAAW,GAAG,EAAlB;EACA,IAAIC,QAAQ,GAAG,GAAf,CAzN4B,CAyNR;;EACpB,IAAIC,SAAS,GAAG,GAAhB,CA1N4B,CA0NP;;EAErB;;EACA,IAAIC,aAAa,GAAG,OAApB;EACA,IAAIC,aAAa,GAAG,YAApB,CA9N4B,CA8NM;;EAClC,IAAIC,eAAe,GAAG,2BAAtB,CA/N4B,CA+NuB;;EAEnD;;EACA,IAAIC,MAAM,GAAG;IACZ,YAAY,iDADA;IAEZ,aAAa,gDAFD;IAGZ,iBAAiB;EAHL,CAAb;EAMA;;EACA,IAAIC,aAAa,GAAGZ,IAAI,GAAGC,IAA3B;EACA,IAAIY,KAAK,GAAGC,IAAI,CAACD,KAAjB;EACA,IAAIE,kBAAkB,GAAGC,MAAM,CAACC,YAAhC;EAEA;;EAEA;AACA;AACA;AACA;AACA;AACA;;EACA,SAASC,OAAT,CAAiBC,IAAjB,EAAuB;IACtB,MAAM,IAAIC,UAAJ,CAAeT,MAAM,CAACQ,IAAD,CAArB,CAAN;EACA;EAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACA,SAASE,GAAT,CAAaC,KAAb,EAAoBC,EAApB,EAAwB;IACvB,IAAIC,MAAM,GAAG,EAAb;IACA,IAAI7J,MAAM,GAAG2J,KAAK,CAAC3J,MAAnB;;IACA,OAAOA,MAAM,EAAb,EAAiB;MAChB6J,MAAM,CAAC7J,MAAD,CAAN,GAAiB4J,EAAE,CAACD,KAAK,CAAC3J,MAAD,CAAN,CAAnB;IACA;;IACD,OAAO6J,MAAP;EACA;EAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACA,SAASC,SAAT,CAAmBC,MAAnB,EAA2BH,EAA3B,EAA+B;IAC9B,IAAII,KAAK,GAAGD,MAAM,CAAC9I,KAAP,CAAa,GAAb,CAAZ;IACA,IAAI4I,MAAM,GAAG,EAAb;;IACA,IAAIG,KAAK,CAAChK,MAAN,GAAe,CAAnB,EAAsB;MACrB;MACA;MACA6J,MAAM,GAAGG,KAAK,CAAC,CAAD,CAAL,GAAW,GAApB;MACAD,MAAM,GAAGC,KAAK,CAAC,CAAD,CAAd;IACA,CAR6B,CAS9B;;;IACAD,MAAM,GAAGA,MAAM,CAACE,OAAP,CAAelB,eAAf,EAAgC,MAAhC,CAAT;IACA,IAAImB,MAAM,GAAGH,MAAM,CAAC9I,KAAP,CAAa,GAAb,CAAb;IACA,IAAIkJ,OAAO,GAAGT,GAAG,CAACQ,MAAD,EAASN,EAAT,CAAH,CAAgBrJ,IAAhB,CAAqB,GAArB,CAAd;IACA,OAAOsJ,MAAM,GAAGM,OAAhB;EACA;EAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACA,SAASC,UAAT,CAAoBL,MAApB,EAA4B;IAC3B,IAAIM,MAAM,GAAG,EAAb;IACA,IAAIC,OAAO,GAAG,CAAd;IACA,IAAItK,MAAM,GAAG+J,MAAM,CAAC/J,MAApB;;IACA,OAAOsK,OAAO,GAAGtK,MAAjB,EAAyB;MACxB,IAAI6H,KAAK,GAAGkC,MAAM,CAACQ,UAAP,CAAkBD,OAAO,EAAzB,CAAZ;;MACA,IAAIzC,KAAK,IAAI,MAAT,IAAmBA,KAAK,IAAI,MAA5B,IAAsCyC,OAAO,GAAGtK,MAApD,EAA4D;QAC3D;QACA,IAAIwK,KAAK,GAAGT,MAAM,CAACQ,UAAP,CAAkBD,OAAO,EAAzB,CAAZ;;QACA,IAAI,CAACE,KAAK,GAAG,MAAT,KAAoB,MAAxB,EAAgC;UAC/B;UACAH,MAAM,CAACzC,IAAP,CAAY,CAAC,CAACC,KAAK,GAAG,KAAT,KAAmB,EAApB,KAA2B2C,KAAK,GAAG,KAAnC,IAA4C,OAAxD;QACA,CAHD,MAGO;UACN;UACA;UACAH,MAAM,CAACzC,IAAP,CAAYC,KAAZ;UACAyC,OAAO;QACP;MACD,CAZD,MAYO;QACND,MAAM,CAACzC,IAAP,CAAYC,KAAZ;MACA;IACD;;IACD,OAAOwC,MAAP;EACA;EAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACA,IAAII,UAAU,GAAG,SAASA,UAAT,CAAoBd,KAApB,EAA2B;IAC3C,OAAON,MAAM,CAACqB,aAAP,CAAqBC,KAArB,CAA2BtB,MAA3B,EAAmCpB,iBAAiB,CAAC0B,KAAD,CAApD,CAAP;EACA,CAFD;EAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACA,IAAIiB,YAAY,GAAG,SAASA,YAAT,CAAsBC,SAAtB,EAAiC;IACnD,IAAIA,SAAS,GAAG,IAAZ,GAAmB,IAAvB,EAA6B;MAC5B,OAAOA,SAAS,GAAG,IAAnB;IACA;;IACD,IAAIA,SAAS,GAAG,IAAZ,GAAmB,IAAvB,EAA6B;MAC5B,OAAOA,SAAS,GAAG,IAAnB;IACA;;IACD,IAAIA,SAAS,GAAG,IAAZ,GAAmB,IAAvB,EAA6B;MAC5B,OAAOA,SAAS,GAAG,IAAnB;IACA;;IACD,OAAOxC,IAAP;EACA,CAXD;EAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACA,IAAIyC,YAAY,GAAG,SAASA,YAAT,CAAsBC,KAAtB,EAA6BC,IAA7B,EAAmC;IACrD;IACA;IACA,OAAOD,KAAK,GAAG,EAAR,GAAa,MAAMA,KAAK,GAAG,EAAd,CAAb,IAAkC,CAACC,IAAI,IAAI,CAAT,KAAe,CAAjD,CAAP;EACA,CAJD;EAMA;AACA;AACA;AACA;AACA;;;EACA,IAAIC,KAAK,GAAG,SAASA,KAAT,CAAeC,KAAf,EAAsBC,SAAtB,EAAiCC,SAAjC,EAA4C;IACvD,IAAIC,CAAC,GAAG,CAAR;IACAH,KAAK,GAAGE,SAAS,GAAGlC,KAAK,CAACgC,KAAK,GAAGzC,IAAT,CAAR,GAAyByC,KAAK,IAAI,CAAnD;IACAA,KAAK,IAAIhC,KAAK,CAACgC,KAAK,GAAGC,SAAT,CAAd;;IACA;IAAO;IAAuBD,KAAK,GAAGjC,aAAa,GAAGV,IAAhB,IAAwB,CAA9D,EAAiE8C,CAAC,IAAIhD,IAAtE,EAA4E;MAC3E6C,KAAK,GAAGhC,KAAK,CAACgC,KAAK,GAAGjC,aAAT,CAAb;IACA;;IACD,OAAOC,KAAK,CAACmC,CAAC,GAAG,CAACpC,aAAa,GAAG,CAAjB,IAAsBiC,KAAtB,IAA+BA,KAAK,GAAG1C,IAAvC,CAAL,CAAZ;EACA,CARD;EAUA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACA,IAAI8C,MAAM,GAAG,SAASA,MAAT,CAAgBC,KAAhB,EAAuB;IACnC;IACA,IAAIlB,MAAM,GAAG,EAAb;IACA,IAAImB,WAAW,GAAGD,KAAK,CAACvL,MAAxB;IACA,IAAIiH,CAAC,GAAG,CAAR;IACA,IAAIwE,CAAC,GAAG9C,QAAR;IACA,IAAI+C,IAAI,GAAGhD,WAAX,CANmC,CAQnC;IACA;IACA;;IAEA,IAAIiD,KAAK,GAAGJ,KAAK,CAACK,WAAN,CAAkBhD,SAAlB,CAAZ;;IACA,IAAI+C,KAAK,GAAG,CAAZ,EAAe;MACdA,KAAK,GAAG,CAAR;IACA;;IAED,KAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAApB,EAA2B,EAAEE,CAA7B,EAAgC;MAC/B;MACA,IAAIN,KAAK,CAAChB,UAAN,CAAiBsB,CAAjB,KAAuB,IAA3B,EAAiC;QAChCtC,OAAO,CAAC,WAAD,CAAP;MACA;;MACDc,MAAM,CAACzC,IAAP,CAAY2D,KAAK,CAAChB,UAAN,CAAiBsB,CAAjB,CAAZ;IACA,CAvBkC,CAyBnC;IACA;;;IAEA,KAAK,IAAIC,KAAK,GAAGH,KAAK,GAAG,CAAR,GAAYA,KAAK,GAAG,CAApB,GAAwB,CAAzC,EAA4CG,KAAK,GAAGN,WAApD;IAAkE;IAAyB;MAE1F;MACA;MACA;MACA;MACA;MACA,IAAIO,IAAI,GAAG9E,CAAX;;MACA,KAAK,IAAI+E,CAAC,GAAG,CAAR,EAAWX,CAAC,GAAGhD,IAApB;MAA2B;MAAkBgD,CAAC,IAAIhD,IAAlD,EAAwD;QAEvD,IAAIyD,KAAK,IAAIN,WAAb,EAA0B;UACzBjC,OAAO,CAAC,eAAD,CAAP;QACA;;QAED,IAAIwB,KAAK,GAAGH,YAAY,CAACW,KAAK,CAAChB,UAAN,CAAiBuB,KAAK,EAAtB,CAAD,CAAxB;;QAEA,IAAIf,KAAK,IAAI1C,IAAT,IAAiB0C,KAAK,GAAG7B,KAAK,CAAC,CAACd,MAAM,GAAGnB,CAAV,IAAe+E,CAAhB,CAAlC,EAAsD;UACrDzC,OAAO,CAAC,UAAD,CAAP;QACA;;QAEDtC,CAAC,IAAI8D,KAAK,GAAGiB,CAAb;QACA,IAAIC,CAAC,GAAGZ,CAAC,IAAIK,IAAL,GAAYpD,IAAZ,GAAmB+C,CAAC,IAAIK,IAAI,GAAGnD,IAAZ,GAAmBA,IAAnB,GAA0B8C,CAAC,GAAGK,IAAzD;;QAEA,IAAIX,KAAK,GAAGkB,CAAZ,EAAe;UACd;QACA;;QAED,IAAIC,UAAU,GAAG7D,IAAI,GAAG4D,CAAxB;;QACA,IAAID,CAAC,GAAG9C,KAAK,CAACd,MAAM,GAAG8D,UAAV,CAAb,EAAoC;UACnC3C,OAAO,CAAC,UAAD,CAAP;QACA;;QAEDyC,CAAC,IAAIE,UAAL;MACA;;MAED,IAAIC,GAAG,GAAG9B,MAAM,CAACrK,MAAP,GAAgB,CAA1B;MACA0L,IAAI,GAAGT,KAAK,CAAChE,CAAC,GAAG8E,IAAL,EAAWI,GAAX,EAAgBJ,IAAI,IAAI,CAAxB,CAAZ,CApC0F,CAsC1F;MACA;;MACA,IAAI7C,KAAK,CAACjC,CAAC,GAAGkF,GAAL,CAAL,GAAiB/D,MAAM,GAAGqD,CAA9B,EAAiC;QAChClC,OAAO,CAAC,UAAD,CAAP;MACA;;MAEDkC,CAAC,IAAIvC,KAAK,CAACjC,CAAC,GAAGkF,GAAL,CAAV;MACAlF,CAAC,IAAIkF,GAAL,CA7C0F,CA+C1F;;MACA9B,MAAM,CAAC+B,MAAP,CAAcnF,CAAC,EAAf,EAAmB,CAAnB,EAAsBwE,CAAtB;IACA;;IAED,OAAOpC,MAAM,CAACqB,aAAP,CAAqBC,KAArB,CAA2BtB,MAA3B,EAAmCgB,MAAnC,CAAP;EACA,CAhFD;EAkFA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACA,IAAIgC,MAAM,GAAG,SAASA,MAAT,CAAgBd,KAAhB,EAAuB;IACnC,IAAIlB,MAAM,GAAG,EAAb,CADmC,CAGnC;;IACAkB,KAAK,GAAGnB,UAAU,CAACmB,KAAD,CAAlB,CAJmC,CAMnC;;IACA,IAAIC,WAAW,GAAGD,KAAK,CAACvL,MAAxB,CAPmC,CASnC;;IACA,IAAIyL,CAAC,GAAG9C,QAAR;IACA,IAAIuC,KAAK,GAAG,CAAZ;IACA,IAAIQ,IAAI,GAAGhD,WAAX,CAZmC,CAcnC;;IACA,IAAI4D,yBAAyB,GAAG,IAAhC;IACA,IAAIC,iBAAiB,GAAG,KAAxB;IACA,IAAIC,cAAc,GAAG5L,SAArB;;IAEA,IAAI;MACH,KAAK,IAAI6L,SAAS,GAAGlB,KAAK,CAAChE,MAAM,CAACC,QAAR,CAAL,EAAhB,EAA0CkF,KAA/C,EAAsD,EAAEJ,yBAAyB,GAAG,CAACI,KAAK,GAAGD,SAAS,CAAC/E,IAAV,EAAT,EAA2BC,IAAzD,CAAtD,EAAsH2E,yBAAyB,GAAG,IAAlJ,EAAwJ;QACvJ,IAAIK,cAAc,GAAGD,KAAK,CAAC7E,KAA3B;;QAEA,IAAI8E,cAAc,GAAG,IAArB,EAA2B;UAC1BtC,MAAM,CAACzC,IAAP,CAAYwB,kBAAkB,CAACuD,cAAD,CAA9B;QACA;MACD;IACD,CARD,CAQE,OAAO7E,GAAP,EAAY;MACbyE,iBAAiB,GAAG,IAApB;MACAC,cAAc,GAAG1E,GAAjB;IACA,CAXD,SAWU;MACT,IAAI;QACH,IAAI,CAACwE,yBAAD,IAA8BG,SAAS,CAACG,MAA5C,EAAoD;UACnDH,SAAS,CAACG,MAAV;QACA;MACD,CAJD,SAIU;QACT,IAAIL,iBAAJ,EAAuB;UACtB,MAAMC,cAAN;QACA;MACD;IACD;;IAED,IAAIK,WAAW,GAAGxC,MAAM,CAACrK,MAAzB;IACA,IAAI8M,cAAc,GAAGD,WAArB,CA3CmC,CA6CnC;IACA;IAEA;;IACA,IAAIA,WAAJ,EAAiB;MAChBxC,MAAM,CAACzC,IAAP,CAAYgB,SAAZ;IACA,CAnDkC,CAqDnC;;;IACA,OAAOkE,cAAc,GAAGtB,WAAxB,EAAqC;MAEpC;MACA;MACA,IAAIuB,CAAC,GAAG3E,MAAR;MACA,IAAI4E,0BAA0B,GAAG,IAAjC;MACA,IAAIC,kBAAkB,GAAG,KAAzB;MACA,IAAIC,eAAe,GAAGtM,SAAtB;;MAEA,IAAI;QACH,KAAK,IAAIuM,UAAU,GAAG5B,KAAK,CAAChE,MAAM,CAACC,QAAR,CAAL,EAAjB,EAA2C4F,MAAhD,EAAwD,EAAEJ,0BAA0B,GAAG,CAACI,MAAM,GAAGD,UAAU,CAACzF,IAAX,EAAV,EAA6BC,IAA5D,CAAxD,EAA2HqF,0BAA0B,GAAG,IAAxJ,EAA8J;UAC7J,IAAIK,YAAY,GAAGD,MAAM,CAACvF,KAA1B;;UAEA,IAAIwF,YAAY,IAAI5B,CAAhB,IAAqB4B,YAAY,GAAGN,CAAxC,EAA2C;YAC1CA,CAAC,GAAGM,YAAJ;UACA;QACD,CAPE,CASH;QACA;;MACA,CAXD,CAWE,OAAOvF,GAAP,EAAY;QACbmF,kBAAkB,GAAG,IAArB;QACAC,eAAe,GAAGpF,GAAlB;MACA,CAdD,SAcU;QACT,IAAI;UACH,IAAI,CAACkF,0BAAD,IAA+BG,UAAU,CAACP,MAA9C,EAAsD;YACrDO,UAAU,CAACP,MAAX;UACA;QACD,CAJD,SAIU;UACT,IAAIK,kBAAJ,EAAwB;YACvB,MAAMC,eAAN;UACA;QACD;MACD;;MAED,IAAII,qBAAqB,GAAGR,cAAc,GAAG,CAA7C;;MACA,IAAIC,CAAC,GAAGtB,CAAJ,GAAQvC,KAAK,CAAC,CAACd,MAAM,GAAG8C,KAAV,IAAmBoC,qBAApB,CAAjB,EAA6D;QAC5D/D,OAAO,CAAC,UAAD,CAAP;MACA;;MAED2B,KAAK,IAAI,CAAC6B,CAAC,GAAGtB,CAAL,IAAU6B,qBAAnB;MACA7B,CAAC,GAAGsB,CAAJ;MAEA,IAAIQ,0BAA0B,GAAG,IAAjC;MACA,IAAIC,kBAAkB,GAAG,KAAzB;MACA,IAAIC,eAAe,GAAG7M,SAAtB;;MAEA,IAAI;QACH,KAAK,IAAI8M,UAAU,GAAGnC,KAAK,CAAChE,MAAM,CAACC,QAAR,CAAL,EAAjB,EAA2CmG,MAAhD,EAAwD,EAAEJ,0BAA0B,GAAG,CAACI,MAAM,GAAGD,UAAU,CAAChG,IAAX,EAAV,EAA6BC,IAA5D,CAAxD,EAA2H4F,0BAA0B,GAAG,IAAxJ,EAA8J;UAC7J,IAAIK,aAAa,GAAGD,MAAM,CAAC9F,KAA3B;;UAEA,IAAI+F,aAAa,GAAGnC,CAAhB,IAAqB,EAAEP,KAAF,GAAU9C,MAAnC,EAA2C;YAC1CmB,OAAO,CAAC,UAAD,CAAP;UACA;;UACD,IAAIqE,aAAa,IAAInC,CAArB,EAAwB;YACvB;YACA,IAAIoC,CAAC,GAAG3C,KAAR;;YACA,KAAK,IAAIG,CAAC,GAAGhD,IAAb;YAAoB;YAAkBgD,CAAC,IAAIhD,IAA3C,EAAiD;cAChD,IAAI4D,CAAC,GAAGZ,CAAC,IAAIK,IAAL,GAAYpD,IAAZ,GAAmB+C,CAAC,IAAIK,IAAI,GAAGnD,IAAZ,GAAmBA,IAAnB,GAA0B8C,CAAC,GAAGK,IAAzD;;cACA,IAAImC,CAAC,GAAG5B,CAAR,EAAW;gBACV;cACA;;cACD,IAAI6B,OAAO,GAAGD,CAAC,GAAG5B,CAAlB;cACA,IAAIC,UAAU,GAAG7D,IAAI,GAAG4D,CAAxB;cACA5B,MAAM,CAACzC,IAAP,CAAYwB,kBAAkB,CAAC0B,YAAY,CAACmB,CAAC,GAAG6B,OAAO,GAAG5B,UAAf,EAA2B,CAA3B,CAAb,CAA9B;cACA2B,CAAC,GAAG3E,KAAK,CAAC4E,OAAO,GAAG5B,UAAX,CAAT;YACA;;YAED7B,MAAM,CAACzC,IAAP,CAAYwB,kBAAkB,CAAC0B,YAAY,CAAC+C,CAAD,EAAI,CAAJ,CAAb,CAA9B;YACAnC,IAAI,GAAGT,KAAK,CAACC,KAAD,EAAQoC,qBAAR,EAA+BR,cAAc,IAAID,WAAjD,CAAZ;YACA3B,KAAK,GAAG,CAAR;YACA,EAAE4B,cAAF;UACA;QACD;MACD,CA3BD,CA2BE,OAAOhF,GAAP,EAAY;QACb0F,kBAAkB,GAAG,IAArB;QACAC,eAAe,GAAG3F,GAAlB;MACA,CA9BD,SA8BU;QACT,IAAI;UACH,IAAI,CAACyF,0BAAD,IAA+BG,UAAU,CAACd,MAA9C,EAAsD;YACrDc,UAAU,CAACd,MAAX;UACA;QACD,CAJD,SAIU;UACT,IAAIY,kBAAJ,EAAwB;YACvB,MAAMC,eAAN;UACA;QACD;MACD;;MAED,EAAEvC,KAAF;MACA,EAAEO,CAAF;IACA;;IACD,OAAOpB,MAAM,CAAC9J,IAAP,CAAY,EAAZ,CAAP;EACA,CAnJD;EAqJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACA,IAAIwN,SAAS,GAAG,SAASA,SAAT,CAAmBxC,KAAnB,EAA0B;IACzC,OAAOzB,SAAS,CAACyB,KAAD,EAAQ,UAAUxB,MAAV,EAAkB;MACzC,OAAOlB,aAAa,CAACmF,IAAd,CAAmBjE,MAAnB,IAA6BuB,MAAM,CAACvB,MAAM,CAAC3J,KAAP,CAAa,CAAb,EAAgBgB,WAAhB,EAAD,CAAnC,GAAqE2I,MAA5E;IACA,CAFe,CAAhB;EAGA,CAJD;EAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACA,IAAIkE,OAAO,GAAG,SAASA,OAAT,CAAiB1C,KAAjB,EAAwB;IACrC,OAAOzB,SAAS,CAACyB,KAAD,EAAQ,UAAUxB,MAAV,EAAkB;MACzC,OAAOjB,aAAa,CAACkF,IAAd,CAAmBjE,MAAnB,IAA6B,SAASsC,MAAM,CAACtC,MAAD,CAA5C,GAAuDA,MAA9D;IACA,CAFe,CAAhB;EAGA,CAJD;EAMA;;EAEA;;;EACA,IAAImE,QAAQ,GAAG;IACd;AACD;AACA;AACA;AACA;IACC,WAAW,OANG;;IAOd;AACD;AACA;AACA;AACA;AACA;AACA;IACC,QAAQ;MACP,UAAU9D,UADH;MAEP,UAAUK;IAFH,CAdM;IAkBd,UAAUa,MAlBI;IAmBd,UAAUe,MAnBI;IAoBd,WAAW4B,OApBG;IAqBd,aAAaF;EArBC,CAAf;EAwBA;AACA;AACA;AACA;AACA;AACA;AACA;;EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EACA,IAAII,OAAO,GAAG,EAAd;;EACA,SAASC,UAAT,CAAoBC,GAApB,EAAyB;IACrB,IAAIC,CAAC,GAAGD,GAAG,CAAC9D,UAAJ,CAAe,CAAf,CAAR;IACA,IAAIgE,CAAC,GAAG,KAAK,CAAb;IACA,IAAID,CAAC,GAAG,EAAR,EAAYC,CAAC,GAAG,OAAOD,CAAC,CAACvN,QAAF,CAAW,EAAX,EAAeM,WAAf,EAAX,CAAZ,KAAyD,IAAIiN,CAAC,GAAG,GAAR,EAAaC,CAAC,GAAG,MAAMD,CAAC,CAACvN,QAAF,CAAW,EAAX,EAAeM,WAAf,EAAV,CAAb,KAAyD,IAAIiN,CAAC,GAAG,IAAR,EAAcC,CAAC,GAAG,MAAM,CAACD,CAAC,IAAI,CAAL,GAAS,GAAV,EAAevN,QAAf,CAAwB,EAAxB,EAA4BM,WAA5B,EAAN,GAAkD,GAAlD,GAAwD,CAACiN,CAAC,GAAG,EAAJ,GAAS,GAAV,EAAevN,QAAf,CAAwB,EAAxB,EAA4BM,WAA5B,EAA5D,CAAd,KAAyHkN,CAAC,GAAG,MAAM,CAACD,CAAC,IAAI,EAAL,GAAU,GAAX,EAAgBvN,QAAhB,CAAyB,EAAzB,EAA6BM,WAA7B,EAAN,GAAmD,GAAnD,GAAyD,CAACiN,CAAC,IAAI,CAAL,GAAS,EAAT,GAAc,GAAf,EAAoBvN,QAApB,CAA6B,EAA7B,EAAiCM,WAAjC,EAAzD,GAA0G,GAA1G,GAAgH,CAACiN,CAAC,GAAG,EAAJ,GAAS,GAAV,EAAevN,QAAf,CAAwB,EAAxB,EAA4BM,WAA5B,EAApH;IAC3O,OAAOkN,CAAP;EACH;;EACD,SAASC,WAAT,CAAqB/N,GAArB,EAA0B;IACtB,IAAIgO,MAAM,GAAG,EAAb;IACA,IAAIxH,CAAC,GAAG,CAAR;IACA,IAAIyH,EAAE,GAAGjO,GAAG,CAACT,MAAb;;IACA,OAAOiH,CAAC,GAAGyH,EAAX,EAAe;MACX,IAAIJ,CAAC,GAAGK,QAAQ,CAAClO,GAAG,CAACmO,MAAJ,CAAW3H,CAAC,GAAG,CAAf,EAAkB,CAAlB,CAAD,EAAuB,EAAvB,CAAhB;;MACA,IAAIqH,CAAC,GAAG,GAAR,EAAa;QACTG,MAAM,IAAIpF,MAAM,CAACC,YAAP,CAAoBgF,CAApB,CAAV;QACArH,CAAC,IAAI,CAAL;MACH,CAHD,MAGO,IAAIqH,CAAC,IAAI,GAAL,IAAYA,CAAC,GAAG,GAApB,EAAyB;QAC5B,IAAII,EAAE,GAAGzH,CAAL,IAAU,CAAd,EAAiB;UACb,IAAI4H,EAAE,GAAGF,QAAQ,CAAClO,GAAG,CAACmO,MAAJ,CAAW3H,CAAC,GAAG,CAAf,EAAkB,CAAlB,CAAD,EAAuB,EAAvB,CAAjB;UACAwH,MAAM,IAAIpF,MAAM,CAACC,YAAP,CAAoB,CAACgF,CAAC,GAAG,EAAL,KAAY,CAAZ,GAAgBO,EAAE,GAAG,EAAzC,CAAV;QACH,CAHD,MAGO;UACHJ,MAAM,IAAIhO,GAAG,CAACmO,MAAJ,CAAW3H,CAAX,EAAc,CAAd,CAAV;QACH;;QACDA,CAAC,IAAI,CAAL;MACH,CARM,MAQA,IAAIqH,CAAC,IAAI,GAAT,EAAc;QACjB,IAAII,EAAE,GAAGzH,CAAL,IAAU,CAAd,EAAiB;UACb,IAAI6H,EAAE,GAAGH,QAAQ,CAAClO,GAAG,CAACmO,MAAJ,CAAW3H,CAAC,GAAG,CAAf,EAAkB,CAAlB,CAAD,EAAuB,EAAvB,CAAjB;;UACA,IAAI8H,EAAE,GAAGJ,QAAQ,CAAClO,GAAG,CAACmO,MAAJ,CAAW3H,CAAC,GAAG,CAAf,EAAkB,CAAlB,CAAD,EAAuB,EAAvB,CAAjB;UACAwH,MAAM,IAAIpF,MAAM,CAACC,YAAP,CAAoB,CAACgF,CAAC,GAAG,EAAL,KAAY,EAAZ,GAAiB,CAACQ,EAAE,GAAG,EAAN,KAAa,CAA9B,GAAkCC,EAAE,GAAG,EAA3D,CAAV;QACH,CAJD,MAIO;UACHN,MAAM,IAAIhO,GAAG,CAACmO,MAAJ,CAAW3H,CAAX,EAAc,CAAd,CAAV;QACH;;QACDA,CAAC,IAAI,CAAL;MACH,CATM,MASA;QACHwH,MAAM,IAAIhO,GAAG,CAACmO,MAAJ,CAAW3H,CAAX,EAAc,CAAd,CAAV;QACAA,CAAC,IAAI,CAAL;MACH;IACJ;;IACD,OAAOwH,MAAP;EACH;;EACD,SAASO,2BAAT,CAAqCC,UAArC,EAAiDC,QAAjD,EAA2D;IACvD,SAASC,gBAAT,CAA0B1O,GAA1B,EAA+B;MAC3B,IAAI2O,MAAM,GAAGZ,WAAW,CAAC/N,GAAD,CAAxB;MACA,OAAO,CAAC2O,MAAM,CAACC,KAAP,CAAaH,QAAQ,CAAC3I,UAAtB,CAAD,GAAqC9F,GAArC,GAA2C2O,MAAlD;IACH;;IACD,IAAIH,UAAU,CAACK,MAAf,EAAuBL,UAAU,CAACK,MAAX,GAAoBjG,MAAM,CAAC4F,UAAU,CAACK,MAAZ,CAAN,CAA0BrF,OAA1B,CAAkCiF,QAAQ,CAACzI,WAA3C,EAAwD0I,gBAAxD,EAA0E/N,WAA1E,GAAwF6I,OAAxF,CAAgGiF,QAAQ,CAACpJ,UAAzG,EAAqH,EAArH,CAApB;IACvB,IAAImJ,UAAU,CAACM,QAAX,KAAwB3O,SAA5B,EAAuCqO,UAAU,CAACM,QAAX,GAAsBlG,MAAM,CAAC4F,UAAU,CAACM,QAAZ,CAAN,CAA4BtF,OAA5B,CAAoCiF,QAAQ,CAACzI,WAA7C,EAA0D0I,gBAA1D,EAA4ElF,OAA5E,CAAoFiF,QAAQ,CAAClJ,YAA7F,EAA2GoI,UAA3G,EAAuHnE,OAAvH,CAA+HiF,QAAQ,CAACzI,WAAxI,EAAqJpF,WAArJ,CAAtB;IACvC,IAAI4N,UAAU,CAACO,IAAX,KAAoB5O,SAAxB,EAAmCqO,UAAU,CAACO,IAAX,GAAkBnG,MAAM,CAAC4F,UAAU,CAACO,IAAZ,CAAN,CAAwBvF,OAAxB,CAAgCiF,QAAQ,CAACzI,WAAzC,EAAsD0I,gBAAtD,EAAwE/N,WAAxE,GAAsF6I,OAAtF,CAA8FiF,QAAQ,CAACjJ,QAAvG,EAAiHmI,UAAjH,EAA6HnE,OAA7H,CAAqIiF,QAAQ,CAACzI,WAA9I,EAA2JpF,WAA3J,CAAlB;IACnC,IAAI4N,UAAU,CAACQ,IAAX,KAAoB7O,SAAxB,EAAmCqO,UAAU,CAACQ,IAAX,GAAkBpG,MAAM,CAAC4F,UAAU,CAACQ,IAAZ,CAAN,CAAwBxF,OAAxB,CAAgCiF,QAAQ,CAACzI,WAAzC,EAAsD0I,gBAAtD,EAAwElF,OAAxE,CAAgFgF,UAAU,CAACK,MAAX,GAAoBJ,QAAQ,CAAChJ,QAA7B,GAAwCgJ,QAAQ,CAAC/I,iBAAjI,EAAoJiI,UAApJ,EAAgKnE,OAAhK,CAAwKiF,QAAQ,CAACzI,WAAjL,EAA8LpF,WAA9L,CAAlB;IACnC,IAAI4N,UAAU,CAACS,KAAX,KAAqB9O,SAAzB,EAAoCqO,UAAU,CAACS,KAAX,GAAmBrG,MAAM,CAAC4F,UAAU,CAACS,KAAZ,CAAN,CAAyBzF,OAAzB,CAAiCiF,QAAQ,CAACzI,WAA1C,EAAuD0I,gBAAvD,EAAyElF,OAAzE,CAAiFiF,QAAQ,CAAC9I,SAA1F,EAAqGgI,UAArG,EAAiHnE,OAAjH,CAAyHiF,QAAQ,CAACzI,WAAlI,EAA+IpF,WAA/I,CAAnB;IACpC,IAAI4N,UAAU,CAACU,QAAX,KAAwB/O,SAA5B,EAAuCqO,UAAU,CAACU,QAAX,GAAsBtG,MAAM,CAAC4F,UAAU,CAACU,QAAZ,CAAN,CAA4B1F,OAA5B,CAAoCiF,QAAQ,CAACzI,WAA7C,EAA0D0I,gBAA1D,EAA4ElF,OAA5E,CAAoFiF,QAAQ,CAAC7I,YAA7F,EAA2G+H,UAA3G,EAAuHnE,OAAvH,CAA+HiF,QAAQ,CAACzI,WAAxI,EAAqJpF,WAArJ,CAAtB;IACvC,OAAO4N,UAAP;EACH;;EAED,SAASW,kBAAT,CAA4BnP,GAA5B,EAAiC;IAC7B,OAAOA,GAAG,CAACwJ,OAAJ,CAAY,SAAZ,EAAuB,IAAvB,KAAgC,GAAvC;EACH;;EACD,SAAS4F,cAAT,CAAwBL,IAAxB,EAA8BN,QAA9B,EAAwC;IACpC,IAAIY,OAAO,GAAGN,IAAI,CAACH,KAAL,CAAWH,QAAQ,CAACxI,WAApB,KAAoC,EAAlD;;IAEA,IAAIqJ,QAAQ,GAAGjJ,aAAa,CAACgJ,OAAD,EAAU,CAAV,CAA5B;IAAA,IACIE,OAAO,GAAGD,QAAQ,CAAC,CAAD,CADtB;;IAGA,IAAIC,OAAJ,EAAa;MACT,OAAOA,OAAO,CAAC/O,KAAR,CAAc,GAAd,EAAmByI,GAAnB,CAAuBkG,kBAAvB,EAA2CrP,IAA3C,CAAgD,GAAhD,CAAP;IACH,CAFD,MAEO;MACH,OAAOiP,IAAP;IACH;EACJ;;EACD,SAASS,cAAT,CAAwBT,IAAxB,EAA8BN,QAA9B,EAAwC;IACpC,IAAIY,OAAO,GAAGN,IAAI,CAACH,KAAL,CAAWH,QAAQ,CAACvI,WAApB,KAAoC,EAAlD;;IAEA,IAAIuJ,SAAS,GAAGpJ,aAAa,CAACgJ,OAAD,EAAU,CAAV,CAA7B;IAAA,IACIE,OAAO,GAAGE,SAAS,CAAC,CAAD,CADvB;IAAA,IAEIC,IAAI,GAAGD,SAAS,CAAC,CAAD,CAFpB;;IAIA,IAAIF,OAAJ,EAAa;MACT,IAAII,qBAAqB,GAAGJ,OAAO,CAAC5O,WAAR,GAAsBH,KAAtB,CAA4B,IAA5B,EAAkCoP,OAAlC,EAA5B;MAAA,IACIC,sBAAsB,GAAGxJ,aAAa,CAACsJ,qBAAD,EAAwB,CAAxB,CAD1C;MAAA,IAEIG,IAAI,GAAGD,sBAAsB,CAAC,CAAD,CAFjC;MAAA,IAGIE,KAAK,GAAGF,sBAAsB,CAAC,CAAD,CAHlC;;MAKA,IAAIG,WAAW,GAAGD,KAAK,GAAGA,KAAK,CAACvP,KAAN,CAAY,GAAZ,EAAiByI,GAAjB,CAAqBkG,kBAArB,CAAH,GAA8C,EAArE;MACA,IAAIc,UAAU,GAAGH,IAAI,CAACtP,KAAL,CAAW,GAAX,EAAgByI,GAAhB,CAAoBkG,kBAApB,CAAjB;MACA,IAAIe,sBAAsB,GAAGzB,QAAQ,CAACxI,WAAT,CAAqBsH,IAArB,CAA0B0C,UAAU,CAACA,UAAU,CAAC1Q,MAAX,GAAoB,CAArB,CAApC,CAA7B;MACA,IAAI4Q,UAAU,GAAGD,sBAAsB,GAAG,CAAH,GAAO,CAA9C;MACA,IAAIE,eAAe,GAAGH,UAAU,CAAC1Q,MAAX,GAAoB4Q,UAA1C;MACA,IAAIE,MAAM,GAAG5Q,KAAK,CAAC0Q,UAAD,CAAlB;;MACA,KAAK,IAAItQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsQ,UAApB,EAAgC,EAAEtQ,CAAlC,EAAqC;QACjCwQ,MAAM,CAACxQ,CAAD,CAAN,GAAYmQ,WAAW,CAACnQ,CAAD,CAAX,IAAkBoQ,UAAU,CAACG,eAAe,GAAGvQ,CAAnB,CAA5B,IAAqD,EAAjE;MACH;;MACD,IAAIqQ,sBAAJ,EAA4B;QACxBG,MAAM,CAACF,UAAU,GAAG,CAAd,CAAN,GAAyBf,cAAc,CAACiB,MAAM,CAACF,UAAU,GAAG,CAAd,CAAP,EAAyB1B,QAAzB,CAAvC;MACH;;MACD,IAAI6B,aAAa,GAAGD,MAAM,CAACE,MAAP,CAAc,UAAUC,GAAV,EAAeC,KAAf,EAAsBpF,KAAtB,EAA6B;QAC3D,IAAI,CAACoF,KAAD,IAAUA,KAAK,KAAK,GAAxB,EAA6B;UACzB,IAAIC,WAAW,GAAGF,GAAG,CAACA,GAAG,CAACjR,MAAJ,GAAa,CAAd,CAArB;;UACA,IAAImR,WAAW,IAAIA,WAAW,CAACrF,KAAZ,GAAoBqF,WAAW,CAACnR,MAAhC,KAA2C8L,KAA9D,EAAqE;YACjEqF,WAAW,CAACnR,MAAZ;UACH,CAFD,MAEO;YACHiR,GAAG,CAACrJ,IAAJ,CAAS;cAAEkE,KAAK,EAAEA,KAAT;cAAgB9L,MAAM,EAAE;YAAxB,CAAT;UACH;QACJ;;QACD,OAAOiR,GAAP;MACH,CAVmB,EAUjB,EAViB,CAApB;MAWA,IAAIG,iBAAiB,GAAGL,aAAa,CAACM,IAAd,CAAmB,UAAUC,CAAV,EAAaC,CAAb,EAAgB;QACvD,OAAOA,CAAC,CAACvR,MAAF,GAAWsR,CAAC,CAACtR,MAApB;MACH,CAFuB,EAErB,CAFqB,CAAxB;MAGA,IAAIwR,OAAO,GAAG,KAAK,CAAnB;;MACA,IAAIJ,iBAAiB,IAAIA,iBAAiB,CAACpR,MAAlB,GAA2B,CAApD,EAAuD;QACnD,IAAIyR,QAAQ,GAAGX,MAAM,CAAC1Q,KAAP,CAAa,CAAb,EAAgBgR,iBAAiB,CAACtF,KAAlC,CAAf;QACA,IAAI4F,OAAO,GAAGZ,MAAM,CAAC1Q,KAAP,CAAagR,iBAAiB,CAACtF,KAAlB,GAA0BsF,iBAAiB,CAACpR,MAAzD,CAAd;QACAwR,OAAO,GAAGC,QAAQ,CAAClR,IAAT,CAAc,GAAd,IAAqB,IAArB,GAA4BmR,OAAO,CAACnR,IAAR,CAAa,GAAb,CAAtC;MACH,CAJD,MAIO;QACHiR,OAAO,GAAGV,MAAM,CAACvQ,IAAP,CAAY,GAAZ,CAAV;MACH;;MACD,IAAI4P,IAAJ,EAAU;QACNqB,OAAO,IAAI,MAAMrB,IAAjB;MACH;;MACD,OAAOqB,OAAP;IACH,CA5CD,MA4CO;MACH,OAAOhC,IAAP;IACH;EACJ;;EACD,IAAImC,SAAS,GAAG,iIAAhB;EACA,IAAIC,qBAAqB,GAAG,GAAGvC,KAAH,CAAS,OAAT,EAAkB,CAAlB,MAAyBzO,SAArD;;EACA,SAASiR,KAAT,CAAeC,SAAf,EAA0B;IACtB,IAAIC,OAAO,GAAGhS,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBa,SAAzC,GAAqDb,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAlF;IAEA,IAAIkP,UAAU,GAAG,EAAjB;IACA,IAAIC,QAAQ,GAAG6C,OAAO,CAACC,GAAR,KAAgB,KAAhB,GAAwBnL,YAAxB,GAAuCD,YAAtD;IACA,IAAImL,OAAO,CAACE,SAAR,KAAsB,QAA1B,EAAoCH,SAAS,GAAG,CAACC,OAAO,CAACzC,MAAR,GAAiByC,OAAO,CAACzC,MAAR,GAAiB,GAAlC,GAAwC,EAAzC,IAA+C,IAA/C,GAAsDwC,SAAlE;IACpC,IAAIhC,OAAO,GAAGgC,SAAS,CAACzC,KAAV,CAAgBsC,SAAhB,CAAd;;IACA,IAAI7B,OAAJ,EAAa;MACT,IAAI8B,qBAAJ,EAA2B;QACvB;QACA3C,UAAU,CAACK,MAAX,GAAoBQ,OAAO,CAAC,CAAD,CAA3B;QACAb,UAAU,CAACM,QAAX,GAAsBO,OAAO,CAAC,CAAD,CAA7B;QACAb,UAAU,CAACO,IAAX,GAAkBM,OAAO,CAAC,CAAD,CAAzB;QACAb,UAAU,CAACiD,IAAX,GAAkBvD,QAAQ,CAACmB,OAAO,CAAC,CAAD,CAAR,EAAa,EAAb,CAA1B;QACAb,UAAU,CAACQ,IAAX,GAAkBK,OAAO,CAAC,CAAD,CAAP,IAAc,EAAhC;QACAb,UAAU,CAACS,KAAX,GAAmBI,OAAO,CAAC,CAAD,CAA1B;QACAb,UAAU,CAACU,QAAX,GAAsBG,OAAO,CAAC,CAAD,CAA7B,CARuB,CASvB;;QACA,IAAIqC,KAAK,CAAClD,UAAU,CAACiD,IAAZ,CAAT,EAA4B;UACxBjD,UAAU,CAACiD,IAAX,GAAkBpC,OAAO,CAAC,CAAD,CAAzB;QACH;MACJ,CAbD,MAaO;QACH;QACA;QACAb,UAAU,CAACK,MAAX,GAAoBQ,OAAO,CAAC,CAAD,CAAP,IAAclP,SAAlC;QACAqO,UAAU,CAACM,QAAX,GAAsBuC,SAAS,CAACM,OAAV,CAAkB,GAAlB,MAA2B,CAAC,CAA5B,GAAgCtC,OAAO,CAAC,CAAD,CAAvC,GAA6ClP,SAAnE;QACAqO,UAAU,CAACO,IAAX,GAAkBsC,SAAS,CAACM,OAAV,CAAkB,IAAlB,MAA4B,CAAC,CAA7B,GAAiCtC,OAAO,CAAC,CAAD,CAAxC,GAA8ClP,SAAhE;QACAqO,UAAU,CAACiD,IAAX,GAAkBvD,QAAQ,CAACmB,OAAO,CAAC,CAAD,CAAR,EAAa,EAAb,CAA1B;QACAb,UAAU,CAACQ,IAAX,GAAkBK,OAAO,CAAC,CAAD,CAAP,IAAc,EAAhC;QACAb,UAAU,CAACS,KAAX,GAAmBoC,SAAS,CAACM,OAAV,CAAkB,GAAlB,MAA2B,CAAC,CAA5B,GAAgCtC,OAAO,CAAC,CAAD,CAAvC,GAA6ClP,SAAhE;QACAqO,UAAU,CAACU,QAAX,GAAsBmC,SAAS,CAACM,OAAV,CAAkB,GAAlB,MAA2B,CAAC,CAA5B,GAAgCtC,OAAO,CAAC,CAAD,CAAvC,GAA6ClP,SAAnE,CATG,CAUH;;QACA,IAAIuR,KAAK,CAAClD,UAAU,CAACiD,IAAZ,CAAT,EAA4B;UACxBjD,UAAU,CAACiD,IAAX,GAAkBJ,SAAS,CAACzC,KAAV,CAAgB,+BAAhB,IAAmDS,OAAO,CAAC,CAAD,CAA1D,GAAgElP,SAAlF;QACH;MACJ;;MACD,IAAIqO,UAAU,CAACO,IAAf,EAAqB;QACjB;QACAP,UAAU,CAACO,IAAX,GAAkBS,cAAc,CAACJ,cAAc,CAACZ,UAAU,CAACO,IAAZ,EAAkBN,QAAlB,CAAf,EAA4CA,QAA5C,CAAhC;MACH,CAhCQ,CAiCT;;;MACA,IAAID,UAAU,CAACK,MAAX,KAAsB1O,SAAtB,IAAmCqO,UAAU,CAACM,QAAX,KAAwB3O,SAA3D,IAAwEqO,UAAU,CAACO,IAAX,KAAoB5O,SAA5F,IAAyGqO,UAAU,CAACiD,IAAX,KAAoBtR,SAA7H,IAA0I,CAACqO,UAAU,CAACQ,IAAtJ,IAA8JR,UAAU,CAACS,KAAX,KAAqB9O,SAAvL,EAAkM;QAC9LqO,UAAU,CAACgD,SAAX,GAAuB,eAAvB;MACH,CAFD,MAEO,IAAIhD,UAAU,CAACK,MAAX,KAAsB1O,SAA1B,EAAqC;QACxCqO,UAAU,CAACgD,SAAX,GAAuB,UAAvB;MACH,CAFM,MAEA,IAAIhD,UAAU,CAACU,QAAX,KAAwB/O,SAA5B,EAAuC;QAC1CqO,UAAU,CAACgD,SAAX,GAAuB,UAAvB;MACH,CAFM,MAEA;QACHhD,UAAU,CAACgD,SAAX,GAAuB,KAAvB;MACH,CA1CQ,CA2CT;;;MACA,IAAIF,OAAO,CAACE,SAAR,IAAqBF,OAAO,CAACE,SAAR,KAAsB,QAA3C,IAAuDF,OAAO,CAACE,SAAR,KAAsBhD,UAAU,CAACgD,SAA5F,EAAuG;QACnGhD,UAAU,CAACoD,KAAX,GAAmBpD,UAAU,CAACoD,KAAX,IAAoB,kBAAkBN,OAAO,CAACE,SAA1B,GAAsC,aAA7E;MACH,CA9CQ,CA+CT;;;MACA,IAAIK,aAAa,GAAGnE,OAAO,CAAC,CAAC4D,OAAO,CAACzC,MAAR,IAAkBL,UAAU,CAACK,MAA7B,IAAuC,EAAxC,EAA4ClO,WAA5C,EAAD,CAA3B,CAhDS,CAiDT;;MACA,IAAI,CAAC2Q,OAAO,CAACQ,cAAT,KAA4B,CAACD,aAAD,IAAkB,CAACA,aAAa,CAACC,cAA7D,CAAJ,EAAkF;QAC9E;QACA,IAAItD,UAAU,CAACO,IAAX,KAAoBuC,OAAO,CAACS,UAAR,IAAsBF,aAAa,IAAIA,aAAa,CAACE,UAAzE,CAAJ,EAA0F;UACtF;UACA,IAAI;YACAvD,UAAU,CAACO,IAAX,GAAkBtB,QAAQ,CAACD,OAAT,CAAiBgB,UAAU,CAACO,IAAX,CAAgBvF,OAAhB,CAAwBiF,QAAQ,CAACzI,WAAjC,EAA8C+H,WAA9C,EAA2DpN,WAA3D,EAAjB,CAAlB;UACH,CAFD,CAEE,OAAOmN,CAAP,EAAU;YACRU,UAAU,CAACoD,KAAX,GAAmBpD,UAAU,CAACoD,KAAX,IAAoB,oEAAoE9D,CAA3G;UACH;QACJ,CAT6E,CAU9E;;;QACAS,2BAA2B,CAACC,UAAD,EAAarI,YAAb,CAA3B;MACH,CAZD,MAYO;QACH;QACAoI,2BAA2B,CAACC,UAAD,EAAaC,QAAb,CAA3B;MACH,CAjEQ,CAkET;;;MACA,IAAIoD,aAAa,IAAIA,aAAa,CAACT,KAAnC,EAA0C;QACtCS,aAAa,CAACT,KAAd,CAAoB5C,UAApB,EAAgC8C,OAAhC;MACH;IACJ,CAtED,MAsEO;MACH9C,UAAU,CAACoD,KAAX,GAAmBpD,UAAU,CAACoD,KAAX,IAAoB,wBAAvC;IACH;;IACD,OAAOpD,UAAP;EACH;;EAED,SAASwD,mBAAT,CAA6BxD,UAA7B,EAAyC8C,OAAzC,EAAkD;IAC9C,IAAI7C,QAAQ,GAAG6C,OAAO,CAACC,GAAR,KAAgB,KAAhB,GAAwBnL,YAAxB,GAAuCD,YAAtD;IACA,IAAI8L,SAAS,GAAG,EAAhB;;IACA,IAAIzD,UAAU,CAACM,QAAX,KAAwB3O,SAA5B,EAAuC;MACnC8R,SAAS,CAAC9K,IAAV,CAAeqH,UAAU,CAACM,QAA1B;MACAmD,SAAS,CAAC9K,IAAV,CAAe,GAAf;IACH;;IACD,IAAIqH,UAAU,CAACO,IAAX,KAAoB5O,SAAxB,EAAmC;MAC/B;MACA8R,SAAS,CAAC9K,IAAV,CAAeqI,cAAc,CAACJ,cAAc,CAACxG,MAAM,CAAC4F,UAAU,CAACO,IAAZ,CAAP,EAA0BN,QAA1B,CAAf,EAAoDA,QAApD,CAAd,CAA4EjF,OAA5E,CAAoFiF,QAAQ,CAACvI,WAA7F,EAA0G,UAAUgM,CAAV,EAAaC,EAAb,EAAiBC,EAAjB,EAAqB;QAC1I,OAAO,MAAMD,EAAN,IAAYC,EAAE,GAAG,QAAQA,EAAX,GAAgB,EAA9B,IAAoC,GAA3C;MACH,CAFc,CAAf;IAGH;;IACD,IAAI,OAAO5D,UAAU,CAACiD,IAAlB,KAA2B,QAA3B,IAAuC,OAAOjD,UAAU,CAACiD,IAAlB,KAA2B,QAAtE,EAAgF;MAC5EQ,SAAS,CAAC9K,IAAV,CAAe,GAAf;MACA8K,SAAS,CAAC9K,IAAV,CAAeyB,MAAM,CAAC4F,UAAU,CAACiD,IAAZ,CAArB;IACH;;IACD,OAAOQ,SAAS,CAAC1S,MAAV,GAAmB0S,SAAS,CAACnS,IAAV,CAAe,EAAf,CAAnB,GAAwCK,SAA/C;EACH;;EAED,IAAIkS,IAAI,GAAG,UAAX;EACA,IAAIC,IAAI,GAAG,aAAX;EACA,IAAIC,IAAI,GAAG,eAAX;EACA,IAAIC,IAAI,GAAG,wBAAX;;EACA,SAASC,iBAAT,CAA2B3H,KAA3B,EAAkC;IAC9B,IAAIlB,MAAM,GAAG,EAAb;;IACA,OAAOkB,KAAK,CAACvL,MAAb,EAAqB;MACjB,IAAIuL,KAAK,CAAC8D,KAAN,CAAYyD,IAAZ,CAAJ,EAAuB;QACnBvH,KAAK,GAAGA,KAAK,CAACtB,OAAN,CAAc6I,IAAd,EAAoB,EAApB,CAAR;MACH,CAFD,MAEO,IAAIvH,KAAK,CAAC8D,KAAN,CAAY0D,IAAZ,CAAJ,EAAuB;QAC1BxH,KAAK,GAAGA,KAAK,CAACtB,OAAN,CAAc8I,IAAd,EAAoB,GAApB,CAAR;MACH,CAFM,MAEA,IAAIxH,KAAK,CAAC8D,KAAN,CAAY2D,IAAZ,CAAJ,EAAuB;QAC1BzH,KAAK,GAAGA,KAAK,CAACtB,OAAN,CAAc+I,IAAd,EAAoB,GAApB,CAAR;QACA3I,MAAM,CAACnJ,GAAP;MACH,CAHM,MAGA,IAAIqK,KAAK,KAAK,GAAV,IAAiBA,KAAK,KAAK,IAA/B,EAAqC;QACxCA,KAAK,GAAG,EAAR;MACH,CAFM,MAEA;QACH,IAAI4H,EAAE,GAAG5H,KAAK,CAAC8D,KAAN,CAAY4D,IAAZ,CAAT;;QACA,IAAIE,EAAJ,EAAQ;UACJ,IAAIC,CAAC,GAAGD,EAAE,CAAC,CAAD,CAAV;UACA5H,KAAK,GAAGA,KAAK,CAACnL,KAAN,CAAYgT,CAAC,CAACpT,MAAd,CAAR;UACAqK,MAAM,CAACzC,IAAP,CAAYwL,CAAZ;QACH,CAJD,MAIO;UACH,MAAM,IAAIC,KAAJ,CAAU,kCAAV,CAAN;QACH;MACJ;IACJ;;IACD,OAAOhJ,MAAM,CAAC9J,IAAP,CAAY,EAAZ,CAAP;EACH;;EAED,SAAS+S,SAAT,CAAmBrE,UAAnB,EAA+B;IAC3B,IAAI8C,OAAO,GAAGhS,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBa,SAAzC,GAAqDb,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAlF;IAEA,IAAImP,QAAQ,GAAG6C,OAAO,CAACC,GAAR,GAAcnL,YAAd,GAA6BD,YAA5C;IACA,IAAI8L,SAAS,GAAG,EAAhB,CAJ2B,CAK3B;;IACA,IAAIJ,aAAa,GAAGnE,OAAO,CAAC,CAAC4D,OAAO,CAACzC,MAAR,IAAkBL,UAAU,CAACK,MAA7B,IAAuC,EAAxC,EAA4ClO,WAA5C,EAAD,CAA3B,CAN2B,CAO3B;;IACA,IAAIkR,aAAa,IAAIA,aAAa,CAACgB,SAAnC,EAA8ChB,aAAa,CAACgB,SAAd,CAAwBrE,UAAxB,EAAoC8C,OAApC;;IAC9C,IAAI9C,UAAU,CAACO,IAAf,EAAqB;MACjB;MACA,IAAIN,QAAQ,CAACvI,WAAT,CAAqBqH,IAArB,CAA0BiB,UAAU,CAACO,IAArC,CAAJ,EAAgD,CAAE,CAAlD,CACA;MAEA;MAHA,KAIK,IAAIuC,OAAO,CAACS,UAAR,IAAsBF,aAAa,IAAIA,aAAa,CAACE,UAAzD,EAAqE;QAClE;QACA,IAAI;UACAvD,UAAU,CAACO,IAAX,GAAkB,CAACuC,OAAO,CAACC,GAAT,GAAe9D,QAAQ,CAACD,OAAT,CAAiBgB,UAAU,CAACO,IAAX,CAAgBvF,OAAhB,CAAwBiF,QAAQ,CAACzI,WAAjC,EAA8C+H,WAA9C,EAA2DpN,WAA3D,EAAjB,CAAf,GAA4G8M,QAAQ,CAACH,SAAT,CAAmBkB,UAAU,CAACO,IAA9B,CAA9H;QACH,CAFD,CAEE,OAAOjB,CAAP,EAAU;UACRU,UAAU,CAACoD,KAAX,GAAmBpD,UAAU,CAACoD,KAAX,IAAoB,iDAAiD,CAACN,OAAO,CAACC,GAAT,GAAe,OAAf,GAAyB,SAA1E,IAAuF,iBAAvF,GAA2GzD,CAAlJ;QACH;MACJ;IACR,CAvB0B,CAwB3B;;;IACAS,2BAA2B,CAACC,UAAD,EAAaC,QAAb,CAA3B;;IACA,IAAI6C,OAAO,CAACE,SAAR,KAAsB,QAAtB,IAAkChD,UAAU,CAACK,MAAjD,EAAyD;MACrDoD,SAAS,CAAC9K,IAAV,CAAeqH,UAAU,CAACK,MAA1B;MACAoD,SAAS,CAAC9K,IAAV,CAAe,GAAf;IACH;;IACD,IAAI2L,SAAS,GAAGd,mBAAmB,CAACxD,UAAD,EAAa8C,OAAb,CAAnC;;IACA,IAAIwB,SAAS,KAAK3S,SAAlB,EAA6B;MACzB,IAAImR,OAAO,CAACE,SAAR,KAAsB,QAA1B,EAAoC;QAChCS,SAAS,CAAC9K,IAAV,CAAe,IAAf;MACH;;MACD8K,SAAS,CAAC9K,IAAV,CAAe2L,SAAf;;MACA,IAAItE,UAAU,CAACQ,IAAX,IAAmBR,UAAU,CAACQ,IAAX,CAAgB+D,MAAhB,CAAuB,CAAvB,MAA8B,GAArD,EAA0D;QACtDd,SAAS,CAAC9K,IAAV,CAAe,GAAf;MACH;IACJ;;IACD,IAAIqH,UAAU,CAACQ,IAAX,KAAoB7O,SAAxB,EAAmC;MAC/B,IAAIwS,CAAC,GAAGnE,UAAU,CAACQ,IAAnB;;MACA,IAAI,CAACsC,OAAO,CAAC0B,YAAT,KAA0B,CAACnB,aAAD,IAAkB,CAACA,aAAa,CAACmB,YAA3D,CAAJ,EAA8E;QAC1EL,CAAC,GAAGF,iBAAiB,CAACE,CAAD,CAArB;MACH;;MACD,IAAIG,SAAS,KAAK3S,SAAlB,EAA6B;QACzBwS,CAAC,GAAGA,CAAC,CAACnJ,OAAF,CAAU,OAAV,EAAmB,MAAnB,CAAJ,CADyB,CACO;MACnC;;MACDyI,SAAS,CAAC9K,IAAV,CAAewL,CAAf;IACH;;IACD,IAAInE,UAAU,CAACS,KAAX,KAAqB9O,SAAzB,EAAoC;MAChC8R,SAAS,CAAC9K,IAAV,CAAe,GAAf;MACA8K,SAAS,CAAC9K,IAAV,CAAeqH,UAAU,CAACS,KAA1B;IACH;;IACD,IAAIT,UAAU,CAACU,QAAX,KAAwB/O,SAA5B,EAAuC;MACnC8R,SAAS,CAAC9K,IAAV,CAAe,GAAf;MACA8K,SAAS,CAAC9K,IAAV,CAAeqH,UAAU,CAACU,QAA1B;IACH;;IACD,OAAO+C,SAAS,CAACnS,IAAV,CAAe,EAAf,CAAP,CA1D2B,CA0DA;EAC9B;;EAED,SAASmT,iBAAT,CAA2BrL,IAA3B,EAAiCsL,QAAjC,EAA2C;IACvC,IAAI5B,OAAO,GAAGhS,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBa,SAAzC,GAAqDb,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAlF;IACA,IAAI6T,iBAAiB,GAAG7T,SAAS,CAAC,CAAD,CAAjC;IAEA,IAAI2B,MAAM,GAAG,EAAb;;IACA,IAAI,CAACkS,iBAAL,EAAwB;MACpBvL,IAAI,GAAGwJ,KAAK,CAACyB,SAAS,CAACjL,IAAD,EAAO0J,OAAP,CAAV,EAA2BA,OAA3B,CAAZ,CADoB,CAC6B;;MACjD4B,QAAQ,GAAG9B,KAAK,CAACyB,SAAS,CAACK,QAAD,EAAW5B,OAAX,CAAV,EAA+BA,OAA/B,CAAhB,CAFoB,CAEqC;IAC5D;;IACDA,OAAO,GAAGA,OAAO,IAAI,EAArB;;IACA,IAAI,CAACA,OAAO,CAAC8B,QAAT,IAAqBF,QAAQ,CAACrE,MAAlC,EAA0C;MACtC5N,MAAM,CAAC4N,MAAP,GAAgBqE,QAAQ,CAACrE,MAAzB,CADsC,CAEtC;;MACA5N,MAAM,CAAC6N,QAAP,GAAkBoE,QAAQ,CAACpE,QAA3B;MACA7N,MAAM,CAAC8N,IAAP,GAAcmE,QAAQ,CAACnE,IAAvB;MACA9N,MAAM,CAACwQ,IAAP,GAAcyB,QAAQ,CAACzB,IAAvB;MACAxQ,MAAM,CAAC+N,IAAP,GAAcyD,iBAAiB,CAACS,QAAQ,CAAClE,IAAT,IAAiB,EAAlB,CAA/B;MACA/N,MAAM,CAACgO,KAAP,GAAeiE,QAAQ,CAACjE,KAAxB;IACH,CARD,MAQO;MACH,IAAIiE,QAAQ,CAACpE,QAAT,KAAsB3O,SAAtB,IAAmC+S,QAAQ,CAACnE,IAAT,KAAkB5O,SAArD,IAAkE+S,QAAQ,CAACzB,IAAT,KAAkBtR,SAAxF,EAAmG;QAC/F;QACAc,MAAM,CAAC6N,QAAP,GAAkBoE,QAAQ,CAACpE,QAA3B;QACA7N,MAAM,CAAC8N,IAAP,GAAcmE,QAAQ,CAACnE,IAAvB;QACA9N,MAAM,CAACwQ,IAAP,GAAcyB,QAAQ,CAACzB,IAAvB;QACAxQ,MAAM,CAAC+N,IAAP,GAAcyD,iBAAiB,CAACS,QAAQ,CAAClE,IAAT,IAAiB,EAAlB,CAA/B;QACA/N,MAAM,CAACgO,KAAP,GAAeiE,QAAQ,CAACjE,KAAxB;MACH,CAPD,MAOO;QACH,IAAI,CAACiE,QAAQ,CAAClE,IAAd,EAAoB;UAChB/N,MAAM,CAAC+N,IAAP,GAAcpH,IAAI,CAACoH,IAAnB;;UACA,IAAIkE,QAAQ,CAACjE,KAAT,KAAmB9O,SAAvB,EAAkC;YAC9Bc,MAAM,CAACgO,KAAP,GAAeiE,QAAQ,CAACjE,KAAxB;UACH,CAFD,MAEO;YACHhO,MAAM,CAACgO,KAAP,GAAerH,IAAI,CAACqH,KAApB;UACH;QACJ,CAPD,MAOO;UACH,IAAIiE,QAAQ,CAAClE,IAAT,CAAc+D,MAAd,CAAqB,CAArB,MAA4B,GAAhC,EAAqC;YACjC9R,MAAM,CAAC+N,IAAP,GAAcyD,iBAAiB,CAACS,QAAQ,CAAClE,IAAV,CAA/B;UACH,CAFD,MAEO;YACH,IAAI,CAACpH,IAAI,CAACkH,QAAL,KAAkB3O,SAAlB,IAA+ByH,IAAI,CAACmH,IAAL,KAAc5O,SAA7C,IAA0DyH,IAAI,CAAC6J,IAAL,KAActR,SAAzE,KAAuF,CAACyH,IAAI,CAACoH,IAAjG,EAAuG;cACnG/N,MAAM,CAAC+N,IAAP,GAAc,MAAMkE,QAAQ,CAAClE,IAA7B;YACH,CAFD,MAEO,IAAI,CAACpH,IAAI,CAACoH,IAAV,EAAgB;cACnB/N,MAAM,CAAC+N,IAAP,GAAckE,QAAQ,CAAClE,IAAvB;YACH,CAFM,MAEA;cACH/N,MAAM,CAAC+N,IAAP,GAAcpH,IAAI,CAACoH,IAAL,CAAUrP,KAAV,CAAgB,CAAhB,EAAmBiI,IAAI,CAACoH,IAAL,CAAU7D,WAAV,CAAsB,GAAtB,IAA6B,CAAhD,IAAqD+H,QAAQ,CAAClE,IAA5E;YACH;;YACD/N,MAAM,CAAC+N,IAAP,GAAcyD,iBAAiB,CAACxR,MAAM,CAAC+N,IAAR,CAA/B;UACH;;UACD/N,MAAM,CAACgO,KAAP,GAAeiE,QAAQ,CAACjE,KAAxB;QACH,CAtBE,CAuBH;;;QACAhO,MAAM,CAAC6N,QAAP,GAAkBlH,IAAI,CAACkH,QAAvB;QACA7N,MAAM,CAAC8N,IAAP,GAAcnH,IAAI,CAACmH,IAAnB;QACA9N,MAAM,CAACwQ,IAAP,GAAc7J,IAAI,CAAC6J,IAAnB;MACH;;MACDxQ,MAAM,CAAC4N,MAAP,GAAgBjH,IAAI,CAACiH,MAArB;IACH;;IACD5N,MAAM,CAACiO,QAAP,GAAkBgE,QAAQ,CAAChE,QAA3B;IACA,OAAOjO,MAAP;EACH;;EAED,SAASoS,OAAT,CAAiBC,OAAjB,EAA0BC,WAA1B,EAAuCjC,OAAvC,EAAgD;IAC5C,IAAIkC,iBAAiB,GAAGxS,MAAM,CAAC;MAAE6N,MAAM,EAAE;IAAV,CAAD,EAAqByC,OAArB,CAA9B;IACA,OAAOuB,SAAS,CAACI,iBAAiB,CAAC7B,KAAK,CAACkC,OAAD,EAAUE,iBAAV,CAAN,EAAoCpC,KAAK,CAACmC,WAAD,EAAcC,iBAAd,CAAzC,EAA2EA,iBAA3E,EAA8F,IAA9F,CAAlB,EAAuHA,iBAAvH,CAAhB;EACH;;EAED,SAASC,SAAT,CAAmBC,GAAnB,EAAwBpC,OAAxB,EAAiC;IAC7B,IAAI,OAAOoC,GAAP,KAAe,QAAnB,EAA6B;MACzBA,GAAG,GAAGb,SAAS,CAACzB,KAAK,CAACsC,GAAD,EAAMpC,OAAN,CAAN,EAAsBA,OAAtB,CAAf;IACH,CAFD,MAEO,IAAIrR,MAAM,CAACyT,GAAD,CAAN,KAAgB,QAApB,EAA8B;MACjCA,GAAG,GAAGtC,KAAK,CAACyB,SAAS,CAACa,GAAD,EAAMpC,OAAN,CAAV,EAA0BA,OAA1B,CAAX;IACH;;IACD,OAAOoC,GAAP;EACH;;EAED,SAASC,KAAT,CAAeC,IAAf,EAAqBC,IAArB,EAA2BvC,OAA3B,EAAoC;IAChC,IAAI,OAAOsC,IAAP,KAAgB,QAApB,EAA8B;MAC1BA,IAAI,GAAGf,SAAS,CAACzB,KAAK,CAACwC,IAAD,EAAOtC,OAAP,CAAN,EAAuBA,OAAvB,CAAhB;IACH,CAFD,MAEO,IAAIrR,MAAM,CAAC2T,IAAD,CAAN,KAAiB,QAArB,EAA+B;MAClCA,IAAI,GAAGf,SAAS,CAACe,IAAD,EAAOtC,OAAP,CAAhB;IACH;;IACD,IAAI,OAAOuC,IAAP,KAAgB,QAApB,EAA8B;MAC1BA,IAAI,GAAGhB,SAAS,CAACzB,KAAK,CAACyC,IAAD,EAAOvC,OAAP,CAAN,EAAuBA,OAAvB,CAAhB;IACH,CAFD,MAEO,IAAIrR,MAAM,CAAC4T,IAAD,CAAN,KAAiB,QAArB,EAA+B;MAClCA,IAAI,GAAGhB,SAAS,CAACgB,IAAD,EAAOvC,OAAP,CAAhB;IACH;;IACD,OAAOsC,IAAI,KAAKC,IAAhB;EACH;;EAED,SAASC,eAAT,CAAyB9T,GAAzB,EAA8BsR,OAA9B,EAAuC;IACnC,OAAOtR,GAAG,IAAIA,GAAG,CAACM,QAAJ,GAAekJ,OAAf,CAAuB,CAAC8H,OAAD,IAAY,CAACA,OAAO,CAACC,GAArB,GAA2BpL,YAAY,CAACN,MAAxC,GAAiDO,YAAY,CAACP,MAArF,EAA6F8H,UAA7F,CAAd;EACH;;EAED,SAASoG,iBAAT,CAA2B/T,GAA3B,EAAgCsR,OAAhC,EAAyC;IACrC,OAAOtR,GAAG,IAAIA,GAAG,CAACM,QAAJ,GAAekJ,OAAf,CAAuB,CAAC8H,OAAD,IAAY,CAACA,OAAO,CAACC,GAArB,GAA2BpL,YAAY,CAACH,WAAxC,GAAsDI,YAAY,CAACJ,WAA1F,EAAuG+H,WAAvG,CAAd;EACH;;EAED,IAAIiG,OAAO,GAAG;IACVnF,MAAM,EAAE,MADE;IAEVkD,UAAU,EAAE,IAFF;IAGVX,KAAK,EAAE,SAASA,KAAT,CAAe5C,UAAf,EAA2B8C,OAA3B,EAAoC;MACvC;MACA,IAAI,CAAC9C,UAAU,CAACO,IAAhB,EAAsB;QAClBP,UAAU,CAACoD,KAAX,GAAmBpD,UAAU,CAACoD,KAAX,IAAoB,6BAAvC;MACH;;MACD,OAAOpD,UAAP;IACH,CATS;IAUVqE,SAAS,EAAE,SAASA,SAAT,CAAmBrE,UAAnB,EAA+B8C,OAA/B,EAAwC;MAC/C,IAAI2C,MAAM,GAAGrL,MAAM,CAAC4F,UAAU,CAACK,MAAZ,CAAN,CAA0BlO,WAA1B,OAA4C,OAAzD,CAD+C,CAE/C;;MACA,IAAI6N,UAAU,CAACiD,IAAX,MAAqBwC,MAAM,GAAG,GAAH,GAAS,EAApC,KAA2CzF,UAAU,CAACiD,IAAX,KAAoB,EAAnE,EAAuE;QACnEjD,UAAU,CAACiD,IAAX,GAAkBtR,SAAlB;MACH,CAL8C,CAM/C;;;MACA,IAAI,CAACqO,UAAU,CAACQ,IAAhB,EAAsB;QAClBR,UAAU,CAACQ,IAAX,GAAkB,GAAlB;MACH,CAT8C,CAU/C;MACA;MACA;;;MACA,OAAOR,UAAP;IACH;EAxBS,CAAd;EA2BA,IAAI0F,SAAS,GAAG;IACZrF,MAAM,EAAE,OADI;IAEZkD,UAAU,EAAEiC,OAAO,CAACjC,UAFR;IAGZX,KAAK,EAAE4C,OAAO,CAAC5C,KAHH;IAIZyB,SAAS,EAAEmB,OAAO,CAACnB;EAJP,CAAhB;;EAOA,SAASsB,QAAT,CAAkBC,YAAlB,EAAgC;IAC5B,OAAO,OAAOA,YAAY,CAACH,MAApB,KAA+B,SAA/B,GAA2CG,YAAY,CAACH,MAAxD,GAAiErL,MAAM,CAACwL,YAAY,CAACvF,MAAd,CAAN,CAA4BlO,WAA5B,OAA8C,KAAtH;EACH,CApqC2B,CAqqC5B;;;EACA,IAAI0T,SAAS,GAAG;IACZxF,MAAM,EAAE,IADI;IAEZkD,UAAU,EAAE,IAFA;IAGZX,KAAK,EAAE,SAASA,KAAT,CAAe5C,UAAf,EAA2B8C,OAA3B,EAAoC;MACvC,IAAI8C,YAAY,GAAG5F,UAAnB,CADuC,CAEvC;;MACA4F,YAAY,CAACH,MAAb,GAAsBE,QAAQ,CAACC,YAAD,CAA9B,CAHuC,CAIvC;;MACAA,YAAY,CAACE,YAAb,GAA4B,CAACF,YAAY,CAACpF,IAAb,IAAqB,GAAtB,KAA8BoF,YAAY,CAACnF,KAAb,GAAqB,MAAMmF,YAAY,CAACnF,KAAxC,GAAgD,EAA9E,CAA5B;MACAmF,YAAY,CAACpF,IAAb,GAAoB7O,SAApB;MACAiU,YAAY,CAACnF,KAAb,GAAqB9O,SAArB;MACA,OAAOiU,YAAP;IACH,CAZW;IAaZvB,SAAS,EAAE,SAASA,SAAT,CAAmBuB,YAAnB,EAAiC9C,OAAjC,EAA0C;MACjD;MACA,IAAI8C,YAAY,CAAC3C,IAAb,MAAuB0C,QAAQ,CAACC,YAAD,CAAR,GAAyB,GAAzB,GAA+B,EAAtD,KAA6DA,YAAY,CAAC3C,IAAb,KAAsB,EAAvF,EAA2F;QACvF2C,YAAY,CAAC3C,IAAb,GAAoBtR,SAApB;MACH,CAJgD,CAKjD;;;MACA,IAAI,OAAOiU,YAAY,CAACH,MAApB,KAA+B,SAAnC,EAA8C;QAC1CG,YAAY,CAACvF,MAAb,GAAsBuF,YAAY,CAACH,MAAb,GAAsB,KAAtB,GAA8B,IAApD;QACAG,YAAY,CAACH,MAAb,GAAsB9T,SAAtB;MACH,CATgD,CAUjD;;;MACA,IAAIiU,YAAY,CAACE,YAAjB,EAA+B;QAC3B,IAAIC,qBAAqB,GAAGH,YAAY,CAACE,YAAb,CAA0B9T,KAA1B,CAAgC,GAAhC,CAA5B;QAAA,IACIgU,sBAAsB,GAAGnO,aAAa,CAACkO,qBAAD,EAAwB,CAAxB,CAD1C;QAAA,IAEIvF,IAAI,GAAGwF,sBAAsB,CAAC,CAAD,CAFjC;QAAA,IAGIvF,KAAK,GAAGuF,sBAAsB,CAAC,CAAD,CAHlC;;QAKAJ,YAAY,CAACpF,IAAb,GAAoBA,IAAI,IAAIA,IAAI,KAAK,GAAjB,GAAuBA,IAAvB,GAA8B7O,SAAlD;QACAiU,YAAY,CAACnF,KAAb,GAAqBA,KAArB;QACAmF,YAAY,CAACE,YAAb,GAA4BnU,SAA5B;MACH,CApBgD,CAqBjD;;;MACAiU,YAAY,CAAClF,QAAb,GAAwB/O,SAAxB;MACA,OAAOiU,YAAP;IACH;EArCW,CAAhB;EAwCA,IAAIK,SAAS,GAAG;IACZ5F,MAAM,EAAE,KADI;IAEZkD,UAAU,EAAEsC,SAAS,CAACtC,UAFV;IAGZX,KAAK,EAAEiD,SAAS,CAACjD,KAHL;IAIZyB,SAAS,EAAEwB,SAAS,CAACxB;EAJT,CAAhB;EAOA,IAAI6B,CAAC,GAAG,EAAR;EACA,IAAIrT,KAAK,GAAG,IAAZ,CAttC4B,CAutC5B;;EACA,IAAIc,YAAY,GAAG,4BAA4Bd,KAAK,GAAG,2EAAH,GAAiF,EAAlH,IAAwH,GAA3I;EACA,IAAIK,QAAQ,GAAG,aAAf,CAztC4B,CAytCE;;EAC9B,IAAIG,YAAY,GAAG9B,MAAM,CAACA,MAAM,CAAC,YAAY2B,QAAZ,GAAuB,GAAvB,GAA6BA,QAA7B,GAAwCA,QAAxC,GAAmD,GAAnD,GAAyDA,QAAzD,GAAoEA,QAArE,CAAN,GAAuF,GAAvF,GAA6F3B,MAAM,CAAC,gBAAgB2B,QAAhB,GAA2B,GAA3B,GAAiCA,QAAjC,GAA4CA,QAA7C,CAAnG,GAA4J,GAA5J,GAAkK3B,MAAM,CAAC,MAAM2B,QAAN,GAAiBA,QAAlB,CAAzK,CAAzB,CA1tC4B,CA0tCoM;EAChO;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACA,IAAIiT,OAAO,GAAG,uDAAd;EACA,IAAIC,OAAO,GAAG,4DAAd;EACA,IAAIC,OAAO,GAAGzV,KAAK,CAACwV,OAAD,EAAU,YAAV,CAAnB;EACA,IAAIE,aAAa,GAAG,qCAApB;EACA,IAAIhP,UAAU,GAAG,IAAIR,MAAJ,CAAWnD,YAAX,EAAyB,GAAzB,CAAjB;EACA,IAAI6D,WAAW,GAAG,IAAIV,MAAJ,CAAWzD,YAAX,EAAyB,GAAzB,CAAlB;EACA,IAAIkT,cAAc,GAAG,IAAIzP,MAAJ,CAAWlG,KAAK,CAAC,KAAD,EAAQuV,OAAR,EAAiB,OAAjB,EAA0B,OAA1B,EAAmCE,OAAnC,CAAhB,EAA6D,GAA7D,CAArB;EACA,IAAIG,UAAU,GAAG,IAAI1P,MAAJ,CAAWlG,KAAK,CAAC,KAAD,EAAQ+C,YAAR,EAAsB2S,aAAtB,CAAhB,EAAsD,GAAtD,CAAjB;EACA,IAAIG,WAAW,GAAGD,UAAlB;;EACA,SAAStG,gBAAT,CAA0B1O,GAA1B,EAA+B;IAC3B,IAAI2O,MAAM,GAAGZ,WAAW,CAAC/N,GAAD,CAAxB;IACA,OAAO,CAAC2O,MAAM,CAACC,KAAP,CAAa9I,UAAb,CAAD,GAA4B9F,GAA5B,GAAkC2O,MAAzC;EACH;;EACD,IAAIuG,SAAS,GAAG;IACZrG,MAAM,EAAE,QADI;IAEZuC,KAAK,EAAE,SAAS+D,QAAT,CAAkB3G,UAAlB,EAA8B8C,OAA9B,EAAuC;MAC1C,IAAI8D,gBAAgB,GAAG5G,UAAvB;MACA,IAAI6G,EAAE,GAAGD,gBAAgB,CAACC,EAAjB,GAAsBD,gBAAgB,CAACpG,IAAjB,GAAwBoG,gBAAgB,CAACpG,IAAjB,CAAsBxO,KAAtB,CAA4B,GAA5B,CAAxB,GAA2D,EAA1F;MACA4U,gBAAgB,CAACpG,IAAjB,GAAwB7O,SAAxB;;MACA,IAAIiV,gBAAgB,CAACnG,KAArB,EAA4B;QACxB,IAAIqG,cAAc,GAAG,KAArB;QACA,IAAIC,OAAO,GAAG,EAAd;QACA,IAAIC,OAAO,GAAGJ,gBAAgB,CAACnG,KAAjB,CAAuBzO,KAAvB,CAA6B,GAA7B,CAAd;;QACA,KAAK,IAAIX,CAAC,GAAG,CAAR,EAAWD,EAAE,GAAG4V,OAAO,CAACjW,MAA7B,EAAqCM,CAAC,GAAGD,EAAzC,EAA6C,EAAEC,CAA/C,EAAkD;UAC9C,IAAI4V,MAAM,GAAGD,OAAO,CAAC3V,CAAD,CAAP,CAAWW,KAAX,CAAiB,GAAjB,CAAb;;UACA,QAAQiV,MAAM,CAAC,CAAD,CAAd;YACI,KAAK,IAAL;cACI,IAAIC,OAAO,GAAGD,MAAM,CAAC,CAAD,CAAN,CAAUjV,KAAV,CAAgB,GAAhB,CAAd;;cACA,KAAK,IAAImV,EAAE,GAAG,CAAT,EAAYC,GAAG,GAAGF,OAAO,CAACnW,MAA/B,EAAuCoW,EAAE,GAAGC,GAA5C,EAAiD,EAAED,EAAnD,EAAuD;gBACnDN,EAAE,CAAClO,IAAH,CAAQuO,OAAO,CAACC,EAAD,CAAf;cACH;;cACD;;YACJ,KAAK,SAAL;cACIP,gBAAgB,CAACS,OAAjB,GAA2B9B,iBAAiB,CAAC0B,MAAM,CAAC,CAAD,CAAP,EAAYnE,OAAZ,CAA5C;cACA;;YACJ,KAAK,MAAL;cACI8D,gBAAgB,CAACU,IAAjB,GAAwB/B,iBAAiB,CAAC0B,MAAM,CAAC,CAAD,CAAP,EAAYnE,OAAZ,CAAzC;cACA;;YACJ;cACIgE,cAAc,GAAG,IAAjB;cACAC,OAAO,CAACxB,iBAAiB,CAAC0B,MAAM,CAAC,CAAD,CAAP,EAAYnE,OAAZ,CAAlB,CAAP,GAAiDyC,iBAAiB,CAAC0B,MAAM,CAAC,CAAD,CAAP,EAAYnE,OAAZ,CAAlE;cACA;UAhBR;QAkBH;;QACD,IAAIgE,cAAJ,EAAoBF,gBAAgB,CAACG,OAAjB,GAA2BA,OAA3B;MACvB;;MACDH,gBAAgB,CAACnG,KAAjB,GAAyB9O,SAAzB;;MACA,KAAK,IAAI4V,GAAG,GAAG,CAAV,EAAaC,IAAI,GAAGX,EAAE,CAAC9V,MAA5B,EAAoCwW,GAAG,GAAGC,IAA1C,EAAgD,EAAED,GAAlD,EAAuD;QACnD,IAAIE,IAAI,GAAGZ,EAAE,CAACU,GAAD,CAAF,CAAQvV,KAAR,CAAc,GAAd,CAAX;;QACAyV,IAAI,CAAC,CAAD,CAAJ,GAAUlC,iBAAiB,CAACkC,IAAI,CAAC,CAAD,CAAL,CAA3B;;QACA,IAAI,CAAC3E,OAAO,CAACQ,cAAb,EAA6B;UACzB;UACA,IAAI;YACAmE,IAAI,CAAC,CAAD,CAAJ,GAAUxI,QAAQ,CAACD,OAAT,CAAiBuG,iBAAiB,CAACkC,IAAI,CAAC,CAAD,CAAL,EAAU3E,OAAV,CAAjB,CAAoC3Q,WAApC,EAAjB,CAAV;UACH,CAFD,CAEE,OAAOmN,CAAP,EAAU;YACRsH,gBAAgB,CAACxD,KAAjB,GAAyBwD,gBAAgB,CAACxD,KAAjB,IAA0B,6EAA6E9D,CAAhI;UACH;QACJ,CAPD,MAOO;UACHmI,IAAI,CAAC,CAAD,CAAJ,GAAUlC,iBAAiB,CAACkC,IAAI,CAAC,CAAD,CAAL,EAAU3E,OAAV,CAAjB,CAAoC3Q,WAApC,EAAV;QACH;;QACD0U,EAAE,CAACU,GAAD,CAAF,GAAUE,IAAI,CAACnW,IAAL,CAAU,GAAV,CAAV;MACH;;MACD,OAAOsV,gBAAP;IACH,CAlDW;IAmDZvC,SAAS,EAAE,SAASqD,YAAT,CAAsBd,gBAAtB,EAAwC9D,OAAxC,EAAiD;MACxD,IAAI9C,UAAU,GAAG4G,gBAAjB;MACA,IAAIC,EAAE,GAAGxU,OAAO,CAACuU,gBAAgB,CAACC,EAAlB,CAAhB;;MACA,IAAIA,EAAJ,EAAQ;QACJ,KAAK,IAAIxV,CAAC,GAAG,CAAR,EAAWD,EAAE,GAAGyV,EAAE,CAAC9V,MAAxB,EAAgCM,CAAC,GAAGD,EAApC,EAAwC,EAAEC,CAA1C,EAA6C;UACzC,IAAIsW,MAAM,GAAGvN,MAAM,CAACyM,EAAE,CAACxV,CAAD,CAAH,CAAnB;UACA,IAAIuW,KAAK,GAAGD,MAAM,CAAChL,WAAP,CAAmB,GAAnB,CAAZ;UACA,IAAIkL,SAAS,GAAGF,MAAM,CAACxW,KAAP,CAAa,CAAb,EAAgByW,KAAhB,EAAuB5M,OAAvB,CAA+BxD,WAA/B,EAA4C0I,gBAA5C,EAA8DlF,OAA9D,CAAsExD,WAAtE,EAAmFpF,WAAnF,EAAgG4I,OAAhG,CAAwGuL,cAAxG,EAAwHpH,UAAxH,CAAhB;UACA,IAAI2I,MAAM,GAAGH,MAAM,CAACxW,KAAP,CAAayW,KAAK,GAAG,CAArB,CAAb,CAJyC,CAKzC;;UACA,IAAI;YACAE,MAAM,GAAG,CAAChF,OAAO,CAACC,GAAT,GAAe9D,QAAQ,CAACD,OAAT,CAAiBuG,iBAAiB,CAACuC,MAAD,EAAShF,OAAT,CAAjB,CAAmC3Q,WAAnC,EAAjB,CAAf,GAAoF8M,QAAQ,CAACH,SAAT,CAAmBgJ,MAAnB,CAA7F;UACH,CAFD,CAEE,OAAOxI,CAAP,EAAU;YACRU,UAAU,CAACoD,KAAX,GAAmBpD,UAAU,CAACoD,KAAX,IAAoB,0DAA0D,CAACN,OAAO,CAACC,GAAT,GAAe,OAAf,GAAyB,SAAnF,IAAgG,iBAAhG,GAAoHzD,CAA3J;UACH;;UACDuH,EAAE,CAACxV,CAAD,CAAF,GAAQwW,SAAS,GAAG,GAAZ,GAAkBC,MAA1B;QACH;;QACD9H,UAAU,CAACQ,IAAX,GAAkBqG,EAAE,CAACvV,IAAH,CAAQ,GAAR,CAAlB;MACH;;MACD,IAAIyV,OAAO,GAAGH,gBAAgB,CAACG,OAAjB,GAA2BH,gBAAgB,CAACG,OAAjB,IAA4B,EAArE;MACA,IAAIH,gBAAgB,CAACS,OAArB,EAA8BN,OAAO,CAAC,SAAD,CAAP,GAAqBH,gBAAgB,CAACS,OAAtC;MAC9B,IAAIT,gBAAgB,CAACU,IAArB,EAA2BP,OAAO,CAAC,MAAD,CAAP,GAAkBH,gBAAgB,CAACU,IAAnC;MAC3B,IAAIzF,MAAM,GAAG,EAAb;;MACA,KAAK,IAAIkG,IAAT,IAAiBhB,OAAjB,EAA0B;QACtB,IAAIA,OAAO,CAACgB,IAAD,CAAP,KAAkB7B,CAAC,CAAC6B,IAAD,CAAvB,EAA+B;UAC3BlG,MAAM,CAAClJ,IAAP,CAAYoP,IAAI,CAAC/M,OAAL,CAAaxD,WAAb,EAA0B0I,gBAA1B,EAA4ClF,OAA5C,CAAoDxD,WAApD,EAAiEpF,WAAjE,EAA8E4I,OAA9E,CAAsFwL,UAAtF,EAAkGrH,UAAlG,IAAgH,GAAhH,GAAsH4H,OAAO,CAACgB,IAAD,CAAP,CAAc/M,OAAd,CAAsBxD,WAAtB,EAAmC0I,gBAAnC,EAAqDlF,OAArD,CAA6DxD,WAA7D,EAA0EpF,WAA1E,EAAuF4I,OAAvF,CAA+FyL,WAA/F,EAA4GtH,UAA5G,CAAlI;QACH;MACJ;;MACD,IAAI0C,MAAM,CAAC9Q,MAAX,EAAmB;QACfiP,UAAU,CAACS,KAAX,GAAmBoB,MAAM,CAACvQ,IAAP,CAAY,GAAZ,CAAnB;MACH;;MACD,OAAO0O,UAAP;IACH;EAnFW,CAAhB;EAsFA,IAAIgI,SAAS,GAAG,iBAAhB,CAz0C4B,CA00C5B;;EACA,IAAIC,SAAS,GAAG;IACZ5H,MAAM,EAAE,KADI;IAEZuC,KAAK,EAAE,SAAS+D,QAAT,CAAkB3G,UAAlB,EAA8B8C,OAA9B,EAAuC;MAC1C,IAAIjC,OAAO,GAAGb,UAAU,CAACQ,IAAX,IAAmBR,UAAU,CAACQ,IAAX,CAAgBJ,KAAhB,CAAsB4H,SAAtB,CAAjC;MACA,IAAIE,aAAa,GAAGlI,UAApB;;MACA,IAAIa,OAAJ,EAAa;QACT,IAAIR,MAAM,GAAGyC,OAAO,CAACzC,MAAR,IAAkB6H,aAAa,CAAC7H,MAAhC,IAA0C,KAAvD;QACA,IAAI8H,GAAG,GAAGtH,OAAO,CAAC,CAAD,CAAP,CAAW1O,WAAX,EAAV;QACA,IAAIiW,GAAG,GAAGvH,OAAO,CAAC,CAAD,CAAjB;QACA,IAAIwH,SAAS,GAAGhI,MAAM,GAAG,GAAT,IAAgByC,OAAO,CAACqF,GAAR,IAAeA,GAA/B,CAAhB;QACA,IAAI9E,aAAa,GAAGnE,OAAO,CAACmJ,SAAD,CAA3B;QACAH,aAAa,CAACC,GAAd,GAAoBA,GAApB;QACAD,aAAa,CAACE,GAAd,GAAoBA,GAApB;QACAF,aAAa,CAAC1H,IAAd,GAAqB7O,SAArB;;QACA,IAAI0R,aAAJ,EAAmB;UACf6E,aAAa,GAAG7E,aAAa,CAACT,KAAd,CAAoBsF,aAApB,EAAmCpF,OAAnC,CAAhB;QACH;MACJ,CAZD,MAYO;QACHoF,aAAa,CAAC9E,KAAd,GAAsB8E,aAAa,CAAC9E,KAAd,IAAuB,wBAA7C;MACH;;MACD,OAAO8E,aAAP;IACH,CArBW;IAsBZ7D,SAAS,EAAE,SAASqD,YAAT,CAAsBQ,aAAtB,EAAqCpF,OAArC,EAA8C;MACrD,IAAIzC,MAAM,GAAGyC,OAAO,CAACzC,MAAR,IAAkB6H,aAAa,CAAC7H,MAAhC,IAA0C,KAAvD;MACA,IAAI8H,GAAG,GAAGD,aAAa,CAACC,GAAxB;MACA,IAAIE,SAAS,GAAGhI,MAAM,GAAG,GAAT,IAAgByC,OAAO,CAACqF,GAAR,IAAeA,GAA/B,CAAhB;MACA,IAAI9E,aAAa,GAAGnE,OAAO,CAACmJ,SAAD,CAA3B;;MACA,IAAIhF,aAAJ,EAAmB;QACf6E,aAAa,GAAG7E,aAAa,CAACgB,SAAd,CAAwB6D,aAAxB,EAAuCpF,OAAvC,CAAhB;MACH;;MACD,IAAIwF,aAAa,GAAGJ,aAApB;MACA,IAAIE,GAAG,GAAGF,aAAa,CAACE,GAAxB;MACAE,aAAa,CAAC9H,IAAd,GAAqB,CAAC2H,GAAG,IAAIrF,OAAO,CAACqF,GAAhB,IAAuB,GAAvB,GAA6BC,GAAlD;MACA,OAAOE,aAAP;IACH;EAlCW,CAAhB;EAqCA,IAAIC,IAAI,GAAG,0DAAX,CAh3C4B,CAi3C5B;;EACA,IAAIC,SAAS,GAAG;IACZnI,MAAM,EAAE,UADI;IAEZuC,KAAK,EAAE,SAASA,KAAT,CAAesF,aAAf,EAA8BpF,OAA9B,EAAuC;MAC1C,IAAI2F,cAAc,GAAGP,aAArB;MACAO,cAAc,CAACC,IAAf,GAAsBD,cAAc,CAACL,GAArC;MACAK,cAAc,CAACL,GAAf,GAAqBzW,SAArB;;MACA,IAAI,CAACmR,OAAO,CAAC8B,QAAT,KAAsB,CAAC6D,cAAc,CAACC,IAAhB,IAAwB,CAACD,cAAc,CAACC,IAAf,CAAoBtI,KAApB,CAA0BmI,IAA1B,CAA/C,CAAJ,EAAqF;QACjFE,cAAc,CAACrF,KAAf,GAAuBqF,cAAc,CAACrF,KAAf,IAAwB,oBAA/C;MACH;;MACD,OAAOqF,cAAP;IACH,CAVW;IAWZpE,SAAS,EAAE,SAASA,SAAT,CAAmBoE,cAAnB,EAAmC3F,OAAnC,EAA4C;MACnD,IAAIoF,aAAa,GAAGO,cAApB,CADmD,CAEnD;;MACAP,aAAa,CAACE,GAAd,GAAoB,CAACK,cAAc,CAACC,IAAf,IAAuB,EAAxB,EAA4BvW,WAA5B,EAApB;MACA,OAAO+V,aAAP;IACH;EAhBW,CAAhB;EAmBAhJ,OAAO,CAACsG,OAAO,CAACnF,MAAT,CAAP,GAA0BmF,OAA1B;EACAtG,OAAO,CAACwG,SAAS,CAACrF,MAAX,CAAP,GAA4BqF,SAA5B;EACAxG,OAAO,CAAC2G,SAAS,CAACxF,MAAX,CAAP,GAA4BwF,SAA5B;EACA3G,OAAO,CAAC+G,SAAS,CAAC5F,MAAX,CAAP,GAA4B4F,SAA5B;EACA/G,OAAO,CAACwH,SAAS,CAACrG,MAAX,CAAP,GAA4BqG,SAA5B;EACAxH,OAAO,CAAC+I,SAAS,CAAC5H,MAAX,CAAP,GAA4B4H,SAA5B;EACA/I,OAAO,CAACsJ,SAAS,CAACnI,MAAX,CAAP,GAA4BmI,SAA5B;EAEAjY,OAAO,CAAC2O,OAAR,GAAkBA,OAAlB;EACA3O,OAAO,CAAC4O,UAAR,GAAqBA,UAArB;EACA5O,OAAO,CAACgP,WAAR,GAAsBA,WAAtB;EACAhP,OAAO,CAACqS,KAAR,GAAgBA,KAAhB;EACArS,OAAO,CAAC0T,iBAAR,GAA4BA,iBAA5B;EACA1T,OAAO,CAAC8T,SAAR,GAAoBA,SAApB;EACA9T,OAAO,CAACkU,iBAAR,GAA4BA,iBAA5B;EACAlU,OAAO,CAACsU,OAAR,GAAkBA,OAAlB;EACAtU,OAAO,CAAC0U,SAAR,GAAoBA,SAApB;EACA1U,OAAO,CAAC4U,KAAR,GAAgBA,KAAhB;EACA5U,OAAO,CAAC+U,eAAR,GAA0BA,eAA1B;EACA/U,OAAO,CAACgV,iBAAR,GAA4BA,iBAA5B;EAEA3T,MAAM,CAAC+W,cAAP,CAAsBpY,OAAtB,EAA+B,YAA/B,EAA6C;IAAEqI,KAAK,EAAE;EAAT,CAA7C;AAEC,CAh6CA,CAAD"},"metadata":{},"sourceType":"script"}